---
title: final notes
format:
    html:
        embed-resources: true
---

# At beginning of class

* Highlight expected skills:
  * GIT
  * GH
  * terminal / command line skills
  * Markdown
  * light python - be able to read code and copy
  * change versions of python 
  * follow instructions and install software on your computer

# Technologies used by students in spring 2025

* docker, xamp (provided)
* AWS lightsail
* Supabase

# Discussion on semester-long project

Reinforce that the semester-long project parallels the course.  Skills in the course will map to the deliverables
of the semester-long project.  If you keep up with the homework, you'll be prepared to complete the deliverables of the project.

The semester-long-project is a semester-long project, not a day-long or week-long project.  Don't delay and put it off until
the end of the term.  You won't enjoy life.

The semester-long project requires that YOU learn NEW skills NOT covered by the instructor in the class.  This is an important
learning outcome of our computer science program:  graduates are able to learn and use a new technology on their own. (get correct ABET language here.)

As part of the semester-long project, students will develop and deploy a FULL-STACK web-based database application.  We'll be learning the database stuff in class.  The STUDENT TEAMS are REQUIRED to TEACH THEMSELVES the front-end stuff.


Here is a **revised table of full-stack technologies organized by decade**, now **including XAMPP and LAMP**, along with a column indicating the **current relevance** or "vibe" of each stack. This version helps students see where technologies sit historically, what they were used for, and how modern alternatives have evolved.

---

### üß± Full-Stack Technologies by Decade (Including XAMPP and LAMP)

| Decade    | Stack / Tech               | Database                  | Backend                              | Frontend                      | Deployment / Infra                       | Vibe / Relevance Today            |
| --------- | -------------------------- | ------------------------- | ------------------------------------ | ----------------------------- | ---------------------------------------- | --------------------------------- |
| **1990s** | Classic CGI / Perl         | Oracle, MySQL             | Perl, ASP Classic                    | Static HTML, early JS         | On-prem servers, FTP                     | ‚ö†Ô∏è Obsolete, historical interest  |
| **2000s** | **LAMP**                   | **MySQL**                 | **PHP**                              | HTML + PHP embedded logic     | Linux + Apache                           | üü° Still used in legacy apps      |
| **2000s** | **XAMPP**                  | **MySQL**                 | **PHP, Perl**                        | HTML + PHP embedded logic     | Local GUI stack (Windows/macOS)          | üü° Common in intro/legacy courses |
| **2000s** | Java + JSP + Spring        | MySQL, Oracle             | Java + Spring                        | HTML, JSP                     | Tomcat, WAR files                        | üî¥ Dated, enterprise-only usage   |
| **2010s** | **MERN**                   | **MongoDB**               | **Express (Node.js)**                | **React**                     | Heroku, Docker, AWS                      | üü¢ Still widely used              |
| **2010s** | Django / Flask             | PostgreSQL, SQLite        | Python                               | Bootstrap, Jinja templates    | Heroku, Docker                           | üü¢ Stable, great for learning     |
| **2010s** | Ruby on Rails              | PostgreSQL                | Ruby                                 | Embedded Ruby templates       | Heroku, Capistrano                       | üü° Faded trend, still elegant     |
| **2020s** | **Supabase + Next.js**     | PostgreSQL (managed)      | Supabase Edge Functions, Next.js API | React, Next.js                | Vercel, Netlify, Fly.io                  | üü¢ Modern, minimal DevOps         |
| **2020s** | Firebase + React           | Firebase RTDB / Firestore | Firebase Functions (Node.js)         | React, Vue                    | Firebase Hosting, Vercel                 | üü¢ Frontend-first simplicity      |
| **2020s** | PlanetScale + Vite + React | MySQL (PlanetScale)       | Node.js, serverless                  | React + Vite                  | Vercel, Netlify, Railway                 | üü¢ Fresh, scalable, cloud-native  |
| **2020s** | Deno + Fresh / Bun         | SQLite, Fauna, edge DBs   | Deno, Bun                            | JSX/TSX                       | Edge functions (Deno Deploy, Cloudflare) | üß™ Experimental, cutting-edge     |
| **2020s** | Astro + Supabase           | Supabase (PostgreSQL)     | Astro SSR or API routes              | Astro islands (React/Vue/etc) | Cloudflare Pages, Vercel                 | üü¢ Very modern, low JS footprint  |

---

### üîé Summary of XAMPP and LAMP

| Feature            | LAMP                           | XAMPP                               |
| ------------------ | ------------------------------ | ----------------------------------- |
| Platform           | Linux                          | Cross-platform (Windows/macOS)      |
| Purpose            | Web hosting stack              | Local development                   |
| Default Web Server | Apache                         | Apache                              |
| Use in 2020s       | Mostly legacy PHP or WordPress | Local dev / teaching legacy PHP     |
| Modern Alt         | Docker + Apache/PHP container  | VS Code Dev Containers, Live Server |

---

### ‚úÖ Recommendation for Students

| Student Type            | Recommended Stack                       |
| ----------------------- | --------------------------------------- |
| Beginners               | Supabase + React (with Auth/UI tools)   |
| Interested in DevOps    | Docker + Flask/Postgres                 |
| Wanting modern frontend | Next.js + Supabase or Firebase          |
| Exploring legacy tech   | XAMPP or LAMP (for contrast/comparison) |

Would you like a printable handout or visual timeline chart to share with your class?



### Prompt:

I'm teaching a database class where students are building full-stack applications. I want a comprehensive table that organizes full-stack technologies by **decade**, showing:

- Typical **stacks** (e.g., LAMP, XAMPP, MERN, Supabase + Next.js)
- The **database**, **backend**, **frontend**, and **deployment/infra** components of each stack
- A column for **vibe or relevance today** (e.g., "modern", "dated", "experimental")
- Include both **legacy stacks** like LAMP/XAMPP and **modern stacks** like Supabase, Vercel, Firebase, Bun, Deno, etc.

Also include:
- A follow-up summary table comparing XAMPP and LAMP
- A recommendation section suggesting which stack types are best for different student personas (e.g., beginner, devops-inclined, modern frontend)

Format everything in well-aligned markdown tables, with clean labels and emoji status indicators (üü¢ modern, üü° dated, üî¥ obsolete, üß™ experimental).


# Stack comparison
| Decade | Stack / Tech              | Database               | Backend                        | Frontend                   | Deployment / Infra              | API ‚úÖ | Mobile üì± | GraphQL üß© | Vibe / Relevance Today           |
|--------|---------------------------|------------------------|--------------------------------|----------------------------|----------------------------------|--------|------------|--------------|----------------------------------|
| 1990s  | CGI / Perl                | Oracle, MySQL         | Perl, ASP Classic              | Static HTML, early JS      | On-prem, FTP                    | ‚ùå     | ‚ùå         | ‚ùå           | üî¥ Obsolete                     |
| 2000s  | LAMP                      | MySQL                 | PHP                            | HTML + PHP embedded logic  | Apache on Linux                 | ‚ö†Ô∏è REST via PHP | ‚ö†Ô∏è HTML wrappers | ‚ùå     | üü° Legacy / functional         |
| 2000s  | XAMPP                     | MySQL                 | PHP, Perl                      | HTML + PHP embedded logic  | Local dev on Windows/macOS      | ‚ö†Ô∏è     | ‚ùå         | ‚ùå           | üü° Educational, limited modern use |
| 2010s  | AWS Lightsail             | MySQL, PostgreSQL     | Any (Node.js, Flask, etc.)     | Any                        | VPS-style cloud                 | ‚úÖ     | ‚ö†Ô∏è Mobile backend possible     | ‚ö†Ô∏è Self-hosted                | üü° Practical but not "modern"   |
| 2010s  | Django / Flask            | PostgreSQL, SQLite    | Python                         | Bootstrap + Jinja          | Heroku, Docker, EC2             | ‚úÖ REST | ‚ö†Ô∏è With mobile adapters        | ‚ö†Ô∏è 3rd-party packages        | üü¢ Stable, great for learning   |
| 2010s  | Ruby on Rails             | PostgreSQL            | Ruby                           | Embedded Ruby templates     | Heroku, Capistrano              | ‚úÖ REST | ‚ö†Ô∏è          | üß© via gems                  | üü° Declining, still elegant   |
| 2020s  | Supabase + Next.js        | ‚úÖ PostgreSQL          | Supabase Functions, Next.js API| React + Next.js            | Vercel, Netlify, Fly.io         | ‚úÖ REST & GraphQL | üì± via Expo + Supabase SDK     | üß© Native support            | üü¢ Best SQL full-stack option  |
| 2020s  | PlanetScale + Vite + React| ‚úÖ MySQL               | Serverless / Node.js           | React + Vite               | Railway, Vercel                 | ‚úÖ REST | üì± JS SDK support              | üß© via GraphQL Gateway       | üü¢ Modern, scalable            |
| 2020s  | Astro + Supabase          | ‚úÖ PostgreSQL          | API Routes (Astro SSR)         | Astro + React/Vue/etc.     | Cloudflare Pages, Vercel        | ‚úÖ     | ‚ö†Ô∏è Not mobile-native           | ‚ö†Ô∏è GraphQL possible          | üü¢ Lightweight, content-friendly |
| 2020s  | Deno + Fresh / Bun        | ‚úÖ SQLite, edge DBs    | Deno or Bun                    | JSX/TSX                    | Cloudflare, Deno Deploy         | ‚úÖ     | ‚ö†Ô∏è Lightweight mobile support | ‚ö†Ô∏è Experimental              | üß™ Cutting-edge, evolving      |


# Recommendation

| Student Goal              | Best Stack(s)                                  |
|---------------------------|------------------------------------------------|
| API-first with SQL        | Supabase + Next.js, PlanetScale + Node.js      |
| Mobile app with SQL       | Supabase + Expo, Django + REST API             |
| GraphQL with SQL          | Supabase, PlanetScale (via GraphQL proxy)      |
| Full control / SSH access | AWS Lightsail, Flask + PostgreSQL              |
| Minimal DevOps            | Supabase, Vercel, Netlify                      |


# another set of recommendations

*review the recommendations - order by ease of implementation, less-steep learning curve for undergraduates in a DATABASE course, who have to implement a front end on their own with minimal guidance from professor.*

### Ranked Recommendations (Easiest to Hardest)

| Rank | Student Goal              | Recommended Stack(s)                             | Why It's a Good Fit for Students                                                                 |
|------|---------------------------|--------------------------------------------------|---------------------------------------------------------------------------------------------------|
| 1    | Easy full-stack with SQL  | **Supabase + Next.js (or React)**               | üü¢ Built-in PostgreSQL, Auth, REST, optional GraphQL. <br>üü¢ Great docs, live UI, minimal setup. <br>üü¢ Easy to scaffold both frontend and backend. |
| 2    | Mobile-first + SQL        | **Supabase + Expo (React Native)**              | üü¢ Mobile SDKs, handles auth/storage. <br>üü° Slightly more complex than web. <br>üü¢ Works well for teams wanting an app-like experience. |
| 3    | Simple backend + SQL      | **Django + PostgreSQL**                         | üü¢ Admin panel out-of-the-box. <br>üü° Needs some setup, but great structure and ORM. <br>üü° Templated frontend may feel dated unless React is added. |
| 4    | Fully customizable VPS    | **Flask + PostgreSQL on AWS Lightsail**         | üü° Teaches full control (SSH, server setup). <br>üî¥ Requires Linux skills, deploy pain points. <br>üü° Good if guided by tutorials. |
| 5    | Modern SQL + JS           | **PlanetScale + Vite + React**                  | üü¢ Very modern. <br>üü° PlanetScale uses MySQL with branching and requires Git integration. <br>üü° GraphQL needs external layer. |
| 6    | Cutting-edge exploration  | **Deno + Fresh / Bun + SQLite**                 | üß™ Very fast, modern DX. <br>üî¥ Thin docs, small community. <br>üî¥ Not good for solo learners without web experience. |


### Why Firebase, XAMPP, and LAMP Were Omitted

| Stack       | Reason for Exclusion from Top List                         |
|-------------|-------------------------------------------------------------|
| **Firebase**| ‚ùå Not SQL-based. Firestore and RTDB are NoSQL.             |
| **XAMPP**   | üü° Teaches old PHP/MySQL, but lacks modern dev practices.   |
| **LAMP**    | üü° SQL-compatible but dated. Encourages poor frontend/backend separation. |


### Instructor Summary

- **Best All-Around Stack for Undergrads**:  
  ‚úÖ **Supabase + Next.js** ‚Äî combines modern frontend with easy backend and real SQL. Minimal setup, strong docs, and fits the real-world skills students will use.

- **Best for Ambitious or Experienced Teams**:  
  üîß **PlanetScale + React** or **Flask + PostgreSQL on AWS Lightsail** ‚Äî offer full control but require stronger Git, CLI, and deployment skills.

- **Best for Mobile Apps**:  
  üì± **Supabase + Expo** ‚Äî gives mobile-first experience with authentication and SQL out of the box.

- **Avoid** NoSQL platforms like Firebase unless you're teaching polyglot persistence or client-side‚Äìonly apps.

- **Encourage** students to document how they connect their frontend to SQL-based queries, especially if they use GraphQL or REST APIs.


# course redesign

*I'm teaching ER diagrams, relational algebra, normalization and SQL in a 15-week course. Concurrently, students are working on an independent full-stack project where they need to implement a CRUD front end using the technology of their choice.  I pace the lectures so that by the end of week 13 students have a working back-end.  But it is their responsibility to select a front-end technology and implement it concurrently.  Your thoughts?*

That‚Äôs a strong, well-scaffolded design‚Äîyou're anchoring students in **core database principles (ER, RA, NF, SQL)** while giving them **autonomy** and **real-world experience** in building a full-stack app. You're also giving them **enough backend grounding** by Week 13 to ensure the front-end work has substance behind it.

Here are my thoughts and suggestions to maximize learning and reduce pitfalls:

---

## ‚úÖ Strengths of Your Approach

| Area                            | Strength                                                                                                       |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Theory-practice integration** | Students don‚Äôt just memorize SQL‚Äîthey apply it to a real app with CRUD operations.                             |
| **Project realism**             | Mirrors real-world scenarios: backend-first, frontend concurrency, tech choice autonomy.                       |
| **Timing**                      | Week 13 is a good deadline for a database-backed backend; gives 2 weeks to polish front-end.                   |
| **Skill exposure**              | Students learn ER modeling, normalization, SQL‚Äîand must figure out how to use APIs or ORM tools to power a UI. |

---

## ‚ö†Ô∏è Risks to Mitigate

| Risk                               | Recommendation                                                                                                             |
| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| **Frontend overwhelm**             | Provide a curated list of front-end starter stacks (React + Vite, Next.js, Astro, etc.) with simple examples.              |
| **API/data integration confusion** | Introduce API design and GraphQL/REST concepts lightly by mid-semester (around Weeks 7‚Äì9).                                 |
| **Disconnect from DB schema**      | Encourage students to generate their front-end from their actual schema (via Swagger, Supabase, or GraphQL introspection). |
| **Late panic**                     | Midway milestone: require a basic front-end skeleton (even static pages with buttons) by Week 9 or 10.                     |

---

## üóìÔ∏è Suggested Timeline Overlay (15 Weeks)

| Week  | Core Lecture Topic             | Project Recommendation                             |
| ----- | ------------------------------ | -------------------------------------------------- |
| 1‚Äì2   | ER modeling                    | Design project topic + initial ERD                 |
| 3‚Äì4   | Relational model & constraints | Translate ERD to relational schema                 |
| 5‚Äì6   | Relational algebra             | Assign queries to model key use cases              |
| 7‚Äì8   | Normalization                  | Refine schema, introduce REST vs GraphQL           |
| 9     | SQL SELECT + Aggregation       | Midpoint: front-end mockup + API plan due          |
| 10‚Äì11 | SQL JOINs, Subqueries          | Begin implementing frontend form ‚Üí API ‚Üí DB        |
| 12‚Äì13 | SQL INSERT, UPDATE, DELETE     | Full backend working (CRUD API + database tested)  |
| 14    | Transactions, views, indexes   | Frontend final polish + integration                |
| 15    | Capstone demo                  | Present full app, highlight ERD ‚Üí DB ‚Üí UI workflow |

---

## üß© Support Suggestions

* ‚úÖ Offer **1‚Äì3 frontend templates** (e.g., Supabase + Next.js, Django + Bootstrap, Vite + React) that students can fork
* ‚úÖ Provide a **sample repo with REST or GraphQL** endpoints they can experiment against early
* ‚úÖ Use class time for **low-stakes design reviews** (e.g., "Show your form flow and where it maps to SQL")

---

## üìö Teaching Philosophy Bonus

You're implicitly teaching students the **Double Diamond** of product design:

> Discover (ERD/Modeling) ‚Üí Define (Schema) ‚Üí Develop (API/backend) ‚Üí Deliver (Frontend UX)

This helps them understand how **database theory enables real user interaction**, and gives them a **portfolio-worthy deliverable** with practical relevance.

---

Would you like a Quarto-based student handout that summarizes this timeline and tech stack options for your course site?

---
date: 11/11/2024
execute:
  cache: false
  echo: false
  eval: true
lecture-id: 23
title: Aggregates 1
---

```{python}
#| echo: false
#| label: setup
lecture_id = 23
n_rows = 8

housekeeping_margin_column_width = "9%"
housekeeping_left_column_width="45%"
housekeeping_right_column_width="40%"

housekeeping_vertical_spacer = "25px"
 

discussion_items = [
    'CMSC 427 - User Interfaces - Spring 2025',
    '[Homework 7 - due 11/10](https://virginiacommonwealth.instructure.com/courses/105097/assignments/966531){target="_blank"}',
    '[Homework 8 - due 11/17](https://virginiacommonwealth.instructure.com/courses/105097/assignments/966534){target="_blank"}',
    'Keep working on your semester project!!!'
]

lecture_topics = [
    "[Homework 7 discussion](#homework-7---discussion)",
    "[SQL Aggregate Functions](#sql-aggregate-functions)",
    "[Homework 7 - Advanced Queries](#homework-7---advanced-queries)"
]
```

{{< include "./_template-lecture-housekeeping.qmd" >}}
{{< include "./_template-lecture-gantt.qmd" >}}

# Homework 7 - discussion

## Homework 7 - discussion

Are you having issues with homework 7?

Try commenting out this block of code.

```{.python}
if not errors:
    messages,errors = execute_ddl_from_file( ddl_file_name, cnx)
```

Run your DDL file manually from VSCode, and then rebuild your QMD.

## Homework 7 - Issue #1

:::: {.columns}
::: {.column width=60%}
[![](./assets/homework7-errors-1.png)](https://virginiacommonwealth.instructure.com/courses/105097/assignments/966531){target="_blank"}
:::
::: {.column width=40%}
### Issue #1

This issue involves the connection *cnx*.  

Changes loaded by the DDL file are not fully available until
the connection is closed and reopenned.

### Two solutions

1. manually load DDL file and NOT load it in QMD.

1. force connection reset using *dispose* method.

:::
::::

## Homework 7 - Issue #2

:::: {.columns}
::: {.column width=60%}
[![](./assets/homework7-errors-2.png)](https://virginiacommonwealth.instructure.com/courses/105097/assignments/966531){target="_blank"}
:::
::: {.column width=40%}
### Issue #2

* The database engine we're using (*innodb*) does not 
accurately store record counts in the *information_schema* table. 

* See [this link](https://dev.mysql.com/doc/mysql-infoschema-excerpt/8.0/en/information-schema-tables-table.html){target="_blank"} for more details.

* Ignore the counts, or

* Use `count(*)` to return accurate count.


:::
::::


# SQL Aggregate Functions

```{python}
#| echo: false

from slide_helper import create_database_engine, run_sql_and_return_df, run_ddl_and_confirm, run_ddl_from_file, show_sql_and_results
```

## SQL - Aggregate Functions - Revisit the SELECT

:::: {.columns}
::: {.column width=60%}
### [SELECT statement](https://dev.mysql.com/doc/refman/8.4/en/select.html){target="_blank"}

```{.sql code-line-numbers="3-9"}
SELECT 
    columns_or_expressions -- Choose specific columns or expressions to return
FROM 
    table1
    JOIN_TYPE JOIN table2 ON join_condition
    -- join_type can be: INNER, LEFT, RIGHT, or FULL JOIN with join condition
    JOIN_TYPE JOIN table3 ON join_condition -- Additional joins as needed
WHERE 
    filter_condition -- Filter rows based on a condition
GROUP BY 
    column1, column2, ... -- Group rows based on one or more columns
HAVING 
    aggregate_condition -- Filter groups using aggregate functions (like COUNT, SUM, etc.)
ORDER BY 
    column1 [ASC|DESC], column2 [ASC|DESC], ... -- Sort the final result set
LIMIT 
    number_of_rows; -- (Optional) Limits the number of rows returned
```

:::
::: {.column width=40%}
### Order of Operations

* The **SELECT** statement evaluates from the inside
out.

<p>&nbsp;</p>

### FROM and WHERE

* **FROM** creates a larger, *wider* *join table*

    * *INNER JOIN*

    * *LEFT JOIN*

    * *RIGHT JOIN*

    * *OUTER JOIN*

* **WHERE** makes the *join table* shorter by keeping records

:::
::::



## SQL - Aggregate Functions, GROUP BY and HAVING
:::: {.columns}
::: {.column width=60%}
### [SELECT statement](https://dev.mysql.com/doc/refman/8.4/en/select.html){target="_blank"}

```{.sql code-line-numbers="10-13"}
SELECT 
    columns_or_expressions -- Choose specific columns or expressions to return
FROM 
    table1
    JOIN_TYPE JOIN table2 ON join_condition
    -- join_type can be: INNER, LEFT, RIGHT, or FULL JOIN with join condition
    JOIN_TYPE JOIN table3 ON join_condition -- Additional joins as needed
WHERE 
    filter_condition -- Filter rows based on a condition
GROUP BY 
    column1, column2, ... -- Group rows based on one or more columns
HAVING 
    aggregate_condition -- Filter groups using aggregate functions (like COUNT, SUM, etc.)
ORDER BY 
    column1 [ASC|DESC], column2 [ASC|DESC], ... -- Sort the final result set
LIMIT 
    number_of_rows; -- (Optional) Limits the number of rows returned
```

:::
::: {.column width=40%}

### Aggregate Functions

Aggregate functions return values for blocks of records

* **COUNT()** - returns the number of records in a column group.

* **SUM()** - returns the sum of the values in a column group.

* **AVG()** - returns the average of values in a column group.

* **MIN()** - returns the smallest value in a column group.

* **MAX()** - returns the largest value in a column group.

* Others - [See the DB Manual](https://dev.mysql.com/doc/refman/8.4/en/aggregate-functions-and-modifiers.html){target="_blank"}.
:::
::::


```{python}
#| echo: false

engine_uri = "sqlite:///lecture-23.db"
# create and test the database connection.
cnx = create_database_engine( engine_uri )

if not cnx:
    print(f""" Connection not created """)
else:
    messages, errors = run_ddl_from_file(cnx,"./lecture-23.ddl")
    if errors:
        print(f"""## Error loading lecture-23.ddl
    {errors}
    """)
```


## SQL - Aggregate Functions

### Here is a quick look at the `people` table

```{python}
sql = f"""SELECT
  id,
  first_name,
  last_name,
  email
FROM
  people;
"""
show_sql_and_results( cnx, sql )
```


## SQL - Aggregate Functions - COUNT #1

### How many records are in the table?

COUNT returns the number records for a column.  Use `*` to for all records.

```{python}
sql = """SELECT
  count(*)
FROM
  people
"""
show_sql_and_results( cnx,sql)
```

## SQL - Aggregate Functions - COUNT #2

### How many email addresses in table?

COUNT returns the number of NON-NULL values in a column.

```{python}
sql = """SELECT
  count(email)
from
  people
"""
show_sql_and_results( cnx,sql)
```
`email` contains `NULL` values, and these are ignored when using `COUNT`

## SQL - Aggregate Functions - COUNT #3

### How many people are missing email addresses?

COUNT returns the number of NON-NULL values in a column.

```{python}
sql = """SELECT
  count(*) - count(email) as "Missing emails"
from
  people
"""
show_sql_and_results( cnx,sql)
```
* `email` contains `NULL` values, and these are ignored when using `COUNT`
* Aggregate functions can be used as part of formulas in the `SELECT` statement.


## SQL - Aggregate Functions - MIN and MAX #1

### What are the smallest and largest values for `ID`?

`MIN` and `MAX` work on specific fields by name only.

```{python}
sql = """SELECT
  MIN(id),
  MAX(id)
FROM
  people
"""
show_sql_and_results( cnx,sql)
```

<p>&nbsp;</p>

Using `*` generates an error.

```{python}
sql = """SELECT
  MIN(*)
FROM
  people
"""
show_sql_and_results( cnx,sql,widths=[20,5,75])
```


## SQL - Aggregate Functions - MIN and MAX #2

### Applying `MIN` and `MAX` to string variables

```{python}
sql = """SELECT
  MIN(email),
  MAX(email)
FROM
  people
"""
show_sql_and_results( cnx,sql)
```

* `MIN` and `MAX` use the default `collation` for a given `character set`.

* See the manual for more about [Character Sets and Collations](https://dev.mysql.com/doc/refman/8.4/en/charset-general.html){target="_blank"}

## SQL - Aggregate Functions - SUM and AVG #1

Here is a simple DDL file for the following examples.

```{.sql}
DROP TABLE IF EXISTS avg_example;
CREATE TABLE AVG_EXAMPLE(
    value int
);
INSERT INTO AVG_EXAMPLE (value) VALUES 
(1),
(2),
(3),
(NULL),
(0);
```

## SQL - Aggregate Functions - SUM and AVG #2

### Applying SUM and AVG

We'll create a simple table to explore `SUM` and `AVG`.

```{python}
sql = """SELECT
  *
FROM
  avg_example
"""
show_sql_and_results( cnx, sql )
```

<p>&nbsp;</p>

* This simple table contains five records, each with different values.
* Note that there is one record with a `0` value and a second with a `NULL` value.  
* `0` and `NULL` are treated differently!

## SQL - Aggregate Functions - SUM and AVG #3

### How does SUM and AVG treat NULL values?

```{python}
sql = """SELECT
  SUM(value) as "SUM",
  COUNT(value) as " / COUNT" ,
  AVG(value) as "= AVG"
FROM
  avg_example
"""
show_sql_and_results( cnx, sql )
```
<p>&nbsp;</p>
* Recall the values are [ 0, 1, 2, 3, NULL] - 5 total records.
* `NULL` values are excluded from both `COUNT` and `SUM`.
* Note that `0` is different from `NULL`.

## SQL - `GROUP BY`

* By themselves, aggregate function are applied to the entire table.

* `GROUP BY` can be used to apply aggregate functions to subsets of a table all at once.

### Benefits of `GROUP BY`

* **Data Aggregation**: `GROUP BY` allows aggregation of data, enabling calculations like totals, averages, and counts within specific groups, which is essential for summarizing data meaningfully.

* **Simplified Analysis**: It provides an efficient way to analyze data patterns within each group using aggregate functions, revealing trends and insights across categories (e.g., sales per region or average salary per department).

* **Enhanced Reporting**: By organizing data into groups, `GROUP BY` simplifies the generation of structured reports, making complex datasets more readable and usable for decision-making.

## SQL - Sample Data DDL

For the next few examples, we'll use this table.  You can paste the DDL file into
VS code to follow along.

```{.sql}
DROP TABLE IF EXISTS restaurant_menu;
CREATE TABLE restaurant_menu (
    item_id INT PRIMARY KEY,
    item_name VARCHAR(50),
    category VARCHAR(20),
    calories INT,
    price DECIMAL(5, 2),
    popularity_score DECIMAL(2, 1)
);

INSERT INTO restaurant_menu (item_id, item_name, category, calories, price, popularity_score) VALUES
    (1, 'Mozzarella Sticks', 'Appetizer', 250, 5.99, 4.0),
    (2, 'Garlic Bread', 'Appetizer', NULL, 6.50, 3.5),
    (3, 'Stuffed Mushrooms', 'Appetizer', 300, NULL, NULL),
    (4, 'Grilled Salmon', 'Entree', 700, 12.99, 4.5),
    (5, 'Spaghetti Carbonara', 'Entree', 850, 14.99, NULL),
    (6, 'Vegetable Stir-Fry', 'Entree', NULL, 13.50, 4.4),
    (7, 'Chocolate Lava Cake', 'Dessert', 400, 4.99, 4.8),
    (8, 'Cheesecake', 'Dessert', 450, 5.50, NULL),
    (9, 'Tiramisu', 'Dessert', 500, 6.00, 4.2),
    (10, 'Panna Cotta', 'Dessert', NULL, 5.75, 4.6);
```

### Discussion - is this a *good* schema?

* Yes, it's BCNF as defined above.

* However, it breaks down if `category` if we want to track additional attributes
about `category`, like a `category_description`.


## SQL - `GROUP BY` - Sample Data

```{python}
sql = """SELECT
  *
FROM
  restaurant_menu
ORDER BY
  category,
  item_name
"""
show_sql_and_results( cnx, sql,widths=[23,2,75],headers=["Query","Restaurant Menu"] )
```

* `ORDER BY` sorts first by `category` and when there is a tie moves to sort by `item_name`.
* You can list as many columns in the `ORDER BY` as necessary.


## SQL - `GROUP BY` - Sample Data

```{python}
sql = """SELECT
  *
FROM
  restaurant_menu
"""
show_sql_and_results( cnx, sql,widths=[23,2,75],headers=["Query","Restaurant Menu"],left_side_text = """
### Notes about the menu

* There are 10 items
* Each item belongs to a category,
* Each item as a number of calories, if available, a price and a popularity score.
"""
 )
```

## SQL - `GROUP BY` - Sample Data

### Let's look at the calories column for the entire menu

```{python}
sql = """SELECT
  COUNT(*) as "Item Cnt",
  MIN(calories) as "Min",
  MAX(calories) as "Max",
  ROUND(AVG(calories),0) as "Avg",
  COUNT(*) - COUNT(CALORIES)
    as "# w/o Calories"
FROM
  restaurant_menu
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - calories"] )
```

* We're using all the aggregate functions at once.
* They're applied across all records in the table.
* `NULL` values are excluded.
* `COUNT(*)` returns all the records, while `COUNT(calories)` returns the
non-`NULL` values.

## SQL - `GROUP BY` - `calories` by `category`

### `GROUP BY` example using `calories` and `category`.

```{python}
sql = """SELECT
  category,
  COUNT(*) as "Item Cnt",
  MIN(calories) as "Min",
  MAX(calories) as "Max",
  ROUND(AVG(calories),0) as "Avg",
  COUNT(*) - COUNT(CALORIES) 
    as "# w/o Calories"
FROM
  restaurant_menu
GROUP BY
  category
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - calories by category"] )
```
* We added a `GROUP BY` clause and added `category` to the `SELECT`

* Only columns in the `GROUP BY` can appear in the `SELECT`. Other columns
must be aggregate functions.

## SQL - `GROUP BY` - `price` by `category`

### `GROUP BY` example using `price` and `category`.

```{python}
sql = """SELECT
  category,
  COUNT(*) as "Item Cnt",
  MIN(price) as "Min",
  MAX(price) as "Max",
  ROUND(AVG(price),2) as "Avg",
  COUNT(*) - COUNT(price) as "# w/o price"
FROM
  restaurant_menu
GROUP BY
  category
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - price by category"] )
```

## SQL - `GROUP BY` - `price` by `popularity`

### `GROUP BY` example using `popularity` and `category`.

```{python}
sql = """SELECT
  category,
  COUNT(*) as "Item Cnt",
  MIN(popularity_score) as "Min",
  MAX(popularity_score) as "Max",
  ROUND(AVG(popularity_score),2) as "Avg",
  COUNT(*) - COUNT(popularity_score) as "# w/o popularity"
FROM
  restaurant_menu
GROUP BY
  category
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - popularity by category"] )
```


## SQL - HAVING 

* `WHERE` filters on the raw data
* `HAVING` filters on the results of the `GROUP BY`

### Benefits of `HAVING`

* **Filtering Aggregated Data**: The `HAVING` clause allows you to filter groups of data after aggregation (e.g., filtering by `SUM`, `AVG`, `COUNT`), making it ideal for refining query results based on aggregate conditions.

* **Used with GROUP BY**: `HAVING` is commonly used alongside `GROUP BY` to apply conditions on grouped results, whereas `WHERE` is used for filtering individual rows before grouping.

* **Complex Condition Application**: The `HAVING` clause supports complex conditions with multiple aggregate functions, enabling flexible queries such as filtering groups where total sales exceed a certain amount or average rating is above a threshold.

## SQL - HAVING - example

### List full stats for categories with average calories greater than 400 calories.

```{python}
sql = """SELECT
  category,
  COUNT(*) as "Item Cnt",
  MIN(calories) as "Min",
  MAX(calories) as "Max",
  ROUND(AVG(calories),0) as "Avg",
  COUNT(*) - COUNT(CALORIES) as "# w/o Calories"
FROM
  restaurant_menu
GROUP BY
  category
HAVING
  AVG(calories) >= 400.0
ORDER BY
  AVG(calories) DESC
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - popularity by category"] )
```

* `HAVING` statement requires an aggregate function
* `ORDER BY` statement can use aggregate functions, too.

## SQL - HAVING - example

### List just category names with average calories greater than 400 calories.

```{python}
sql = """SELECT
  category
FROM
  restaurant_menu
GROUP BY
  category
HAVING
  AVG(calories) >= 400.0
ORDER BY
  AVG(calories) DESC
"""
show_sql_and_results( cnx, sql,headers=["Query","Menu - popularity by category"] )
```

* Aggregate functions do not need to be in the `SELECT` in order
to be used.

# Homework 7 - Advanced Queries

## Homework 7 - REMINDER - discussion

Are you having issues with homework 7?

Try commenting out this block of code.

```{.python}
if not errors:
    messages,errors = execute_ddl_from_file( ddl_file_name, cnx)
```

Run your DDL file manually from VSCode, and then rebuild your QMD.


## Homework 7 - Explore people and skills

Using the new queries, let's refine our analysis
of the company resume database (homeworks 6 and 7).

* By using `LEFT JOIN` we're assured of at least one record for
every instance in `SKILLS`.
* If there is no match, the `peopleskills.skills_id` returns NULL
* By testing `peopleskills.skills_id` for `NULL` we explore usage 
patterns of `skills`.

<p>&nbsp;</p>

```{python}
sql = """SELECT
  skills.tag,
  skills.id,
  peopleskills.skills_id
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

## Homework 7 - Which skills are unused?

Let's start easy ...

```{python}
sql = """SELECT
  skills.tag,
  skills.id,
  peopleskills.skills_id
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
WHERE
  peopleskills.skills_id IS NULL
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

## Homework 7 - Which skills are used? (#1)

This table is a problem.  We need to somehow remove duplicate records.

```{python}
sql = """SELECT
  skills.tag,
  skills.id,
  peopleskills.skills_id
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
WHERE
  peopleskills.skills_id IS NOT NULL
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

## Homework 7 - Which skills are used? (#2)

We can remove duplicates with `GROUP BY` to aggregate (combine) duplicate records.

```{python}
sql = """SELECT
  skills.tag,
  skills.id,
  peopleskills.skills_id
FROM
  skills
    left join peopleskills 
      on (skills.id=peopleskills.skills_id)
WHERE
  peopleskills.skills_id IS NOT NULL
GROUP BY
  skills.tag,
  skills.id,
  peopleskills.skills_id
ORDER BY
  skills.tag
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

* Only fields in `GROUP BY` can be listed in SELECT.
* Non-aggregate fields do not need to be listed!

## Homework 7 - Which skills are used? (#3)

Same query as before, removing additional GROUP BY fields

```{python}
sql = """SELECT
  skills.tag as "Used Skills"
FROM
  skills
    left join peopleskills 
      on (skills.id=peopleskills.skills_id)
WHERE
  peopleskills.skills_id IS NOT NULL
GROUP BY
  skills.tag
ORDER BY
  skills.tag
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

### Notes
* `peopleskills.skills_id` is used to filter records, but is
not projected (used) in the SELECT statement
* `skills.tag` is used for grouping and is also projected (used) in SELECT.


## Homework 7 - How many times is each skill used?

This query counts `NON-NULL` values of `peopleskills.skills_id`.

```{python}
sql = """SELECT
  skills.tag,
  COUNT(peopleskills.skills_id) as "Times Used"
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

* What would happen if I used `COUNT(skills.tag)` instead?

## Homework 7 - Which skills are most used? #1

To find the skills most used I can sort by `COUNT`

```{python}
sql = """SELECT
  skills.tag,
  COUNT(peopleskills.skills_id)
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
ORDER BY
  COUNT(peopleskills.skills_id) DESC
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

## Homework 7 - Which skill is most used? #2

To find the most used, I can TRY using LIMIT

```{python}
sql = """SELECT
  skills.tag,
  COUNT(peopleskills.skills_id)
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
ORDER BY
  COUNT(peopleskills.skills_id) DESC
LIMIT
  1
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

### Is this correct?

* No, this approach breaks when there are ties.

## Homework 7 - Which skill is most used? #3

In another (sub-optimal) approach, I can manually pick the `MAX` from the
list using `HAVING`.

```{python}
sql = """SELECT
  skills.tag,
  COUNT(peopleskills.skills_id) as "Most used"
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
HAVING
  COUNT(peopleskills.skills_id)=6
ORDER BY
  skills.tag
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

* In this example, we *hardcode* the maximum value we observed in the data 
into the `HAVING` clause.  

* This works for these data, but it would be great if we could 
calculate the `6` automatically!

## Homework 7 - Which skill is most used? #4

OK - let's find the largest number of times a skill is used.

```{python}
sql = """SELECT
  COUNT(peopleskills.skills_id) as "Most used"
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
ORDER BY
  COUNT(peopleskills.skills_id) DESC
LIMIT 
  1
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```

## Homework 7 - Which skill is most used? #5

Can we combine the last query into our original query?

YES - these are call sub-queries - and we'll dive into them next week!

```{python}
sql = """SELECT
  skills.tag,
  COUNT(peopleskills.skills_id) as "Most used"
FROM
  skills
    left join peopleskills
      on (skills.id=peopleskills.skills_id)
GROUP BY
  skills.tag
HAVING
  COUNT(peopleskills.skills_id)=(
    SELECT
      COUNT(peopleskills.skills_id) as "max_use"
    FROM
      skills
        left join peopleskills
          on (skills.id=peopleskills.skills_id)
    GROUP BY
      skills.tag
    ORDER BY
      COUNT(peopleskills.skills_id) DESC
    LIMIT 
      1
  )
ORDER BY
  skills.tag
"""
show_sql_and_results( cnx, sql,widths=[45,5,50] )
```



{{< include "./_template-lecture-housekeeping.qmd" >}}
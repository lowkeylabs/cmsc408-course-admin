---
title: Basic Operations
---
<!--
Hey Chatgpt.  I'd you to play the role of a professor teaching an undergraduate computer science course covering databases.  The course consists of several modules including: entity-relationship models, relational model and relational algebra, normal forms and normalization, and SQL.

The unit covering relational models and relational algebra includes the following topics:

The relational model and relational algebra form the foundation of modern relational databases, providing a framework for data organization and manipulation. These modules will introduce students to the core concepts of the relational model, including relations, keys, and schemas, and guide them through the essential operations of relational algebra. By the end of this series, students will gain the skills to perform complex queries and understand the practical applications of relational databases in real-world scenarios.


1. [**Introduction to the Relational Model**](intro-to-relational-model.qmd)
   - Definition of the relational model.  
   - Key components: relations, tuples, attributes, domains.  
   - The importance of the relational model in modern databases.  

2. [**Relational Schemas and Keys**](relational-schemas-and-keys.qmd)  
   - Defining relational schemas.  
   - Primary keys, candidate keys, and foreign keys.  
   - The role of keys in ensuring data integrity.  

3. [**Relational Algebra: Basic Operations**](relational-algebra-basic-operations.qmd)  
   - Introduction to relational algebra.  
   - Core operations: selection, projection, and union.  
   - Examples and practical applications of these operations.  

4. [**Set Operations in Relational Algebra**](set-operations-in-relational-algebra.qmd)  
   - Set theory basics and their application in relational algebra.  
   - Intersection, difference, and Cartesian product operations.  
   - Combining relations using set operations.  

5. [**Join Operations in Relational Algebra**](join-operations-in-relational-algebra.qmd)  
   - Inner join, outer join, and their types (left, right, full).  
   - Natural join and theta join.  
   - Use cases and examples of different join operations.  

6. [**Renaming and Division in Relational Algebra**](renaming-and-division-in-relational-algebra.qmd)  
   - The renaming operation and its use in query design.  
   - Division operation: definition and examples.  
   - Application of division in relational queries.  

7. [**Relational Algebra vs SQL**](relational-algebra-vs-sql.qmd)  
   - Mapping relational algebra operations to SQL.  
   - Differences between procedural relational algebra and declarative SQL.  
   - Practical examples demonstrating the use of both.  

8. [**Advanced Relational Algebra Queries**](advanced-relational-algebra-queries.qmd)  
   - Nested queries and complex relational algebra operations.  
   - Handling multiple relations and subqueries.  
   - Performance considerations in advanced queries.  

9. [**Practical Applications of the Relational Model**](practical-applications-of-the-relational-model.qmd)  
   - Real-world use cases of the relational model.  
   - The role of relational databases in enterprise and cloud environments.  
   - Limitations of the relational model and when to consider alternatives.  

I'd like you to create 10 slides covering the following topics:

3. [**Relational Algebra: Basic Operations**](relational-algebra-basic-operations.qmd)  
   - Introduction to relational algebra.  
   - Core operations: selection, projection, and union.  
   - Examples and practical applications of these operations.  

Formatting of each slide is important.  Here are detailed instruction for the formatting of each slide.
1. Each slide should consist of a title denoted in markdown header level 2 (##).
1. Each title should describe the slide contents.  The title should not be numbered, just labeled.
1. Each slide should lead off with 2 sentences summarizing the content of the slide.
1. Each slide should contain 5-7 bullets. The bullets should be included in a special pandoc markdown format as shown below.
1. Each slide should end with an unbolded sentence summarizing the slide.

Below is an example of the formatting:

<start-example>
## Introduction to Entities and Attributes

Entities represent real-world objects or concepts, while attributes describe their characteristics. Understanding these concepts is crucial for effective database design.

::: {.guide-block-left}
- Entities are objects or things in the real world that have a distinct existence.
- Examples include a student, a course, a product, or an employee.
- Attributes are the properties or characteristics of entities.
- Each entity is represented by a set of attributes.
- Attributes describe details like the name, age, or ID of an entity.
:::
::: {.guide-block-right}
:::

*Entities and attributes form the foundation of the data model in database design.*
<end-example>

-->

[Relational algebra](https://en.wikipedia.org/wiki/Relational_algebra) is a formal system used to manipulate and query relational databases. The foundational operations of relational algebra—selection, projection, and union—enable users to filter, narrow, and combine data sets in efficient ways. These operations are critical for building complex queries and are the basis for modern query languages like SQL. By mastering these basic concepts, individuals can optimize their database queries and gain deeper insights into relational data management.


## Introduction to Relational Algebra

Relational algebra is a formal system for manipulating relations, foundational for querying relational databases. This section introduces the core principles and significance of relational algebra in database systems.

```{=html}
<style>
.guide-block-right .quarto-float-fig {
  float: right;
  margin-left: 15px;
  margin-bottom: 15px;
</style>
```


::: {.guide-block-left}
- Relational algebra is a procedural query language.
- It provides the formal foundation for relational database operations.
- Operations in relational algebra manipulate sets of tuples.
- The basic operations include ***selection***, ***projection***, and ***union***.
- Understanding relational algebra is crucial for effective query optimization.
:::

::: {.guide-block-right}
![](./assets/relational-algebra-overview.jpg){fig-align="center" width=25% .lightbox .quarto-float-fig}
:::


*Relational algebra underpins the structure and functionality of modern relational databases.*


```{python}
#| echo: false
import pandas as pd
from tabulate import tabulate
from IPython.display import display, Markdown, HTML

# Define the DataFrame
data = {
    'ID': [1, 2, 3, 4, 5],
    'Course': ['CMSC301', 'CMSC408', 'CMSC445', 'CMSC475', 'CMSC408'],
    'Term': ['Fall 2024','Fall 2024','Fall 2024','Fall 2024','Fall 2023'],
    'Enrl': [220, 175, 37, 128, 125]
}

df = pd.DataFrame(data)

def select_rows(df, column, value):
    # Filter the DataFrame based on the given column and value
    return df[df[column] == value]

def show_df( df, width="80%" ):
#   display(Markdown(df.to_markdown(index=False)))
#   print("<center>")
#   print(tabulate(df, headers='keys', tablefmt='pretty', showindex=False))   
#   print("</center>")
   html_table = df.drop_duplicates().to_html(index=False)

   # Define the HTML with centered table and 75% width
   html_content = f"""
   <div style="text-align: center;">
      <div style="display: inline-block; width: {width};">
         {html_table}
      </div>
   </div>
"""
   display(HTML(html_content))

```

## Selection Operation in Relational Algebra

The selection operation retrieves rows from a relation that meet specified conditions. It allows narrowing down data based on predicates, forming a key part of querying in relational databases.

::: {.guide-block-left}
**σ - Selection (sigma)**

- Selection filters rows based on a condition (predicate).
- The result includes only those tuples that satisfy the predicate.
- Denoted as σ(condition)(Relation)
- It's a unary operation, meaning it operates on a single relation.
- The result of a selection can be used as input into subsequent operations.
- Selection is often used in conjunction with other operations like projection.
- *condition* can contain any relational operator (e.g., =, <, >=, etc.)
:::

::: {.guide-block-right}
**Unicode examples**

Below are examples of what these statement will look like on the Canvas quiz.

1. σ(ID=3)(Courses)

2. σ(Course='CMSC408')(Courses)

3. σ(Enrl<=100)(Courses)

:::

### Properties of the selection operator

::: {.guide-block-left}
**Definition**

$$
\sigma_{\rho}(R) = \{ t \mid t \in R \text{ and } \rho(t) == \text{true} \}
$$

* where $t$ is a row in $R$,
* $\rho$ (the *predicate*) is a boolean expression that evaluates true or false for all rows in $R$,
* $\rho$ consists of one or more *terms* connected by $\land$(and), $\lor$(or), $\neg$(not) function.
* *Terms* in $\rho$ are simple relational expressions evaluated using $=$, $\ne$, $<$, $>$, $\le$, $\ge$.

:::

::: {.guide-block-right}
**Properties**

* *Idempotent* - can be applied multiple times without side effects:

$$
\sigma_{A}(R) = \sigma_{A} ( \sigma_{A}(R) )
$$

* *Commutative* - the order of application doesn't matter:

$$
\sigma_{A}( \sigma_{B}(R) ) = \sigma_{B}( \sigma_{A}(R) )
$$

* *Distributed* - operations can be subdivided and combined

$$
\begin{aligned}
\sigma_{A \land B}( R ) &= \sigma_{A}(R) \cap \sigma_{B}(R) \\
&= \sigma_{A}( \sigma_{B}(R) ) = \sigma_{B}( \sigma_{A}(R) ) \\
\sigma_{A \lor B}( R ) &= \sigma_{A}(R) \cup \sigma_{B}(R)
\end{aligned}
$$

:::

### Selection - σ - Example 1

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df( df )
```
:::

::: {.guide-block-right}
σ(ID=3)(Courses) returns:

```{python}
#| echo: false
new_df = select_rows(df,"ID",3 )
show_df( new_df )
```
:::

### Selection - σ - Example 2

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
σ(Course='CMSC408')(Courses) returns:

```{python}
#| echo: false
new_df = select_rows(df,"Course","CMSC408" )
show_df( new_df )
```
:::

### Selection - σ - Example 3

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::

::: {.guide-block-right}
σ(Enrl<=100)(Courses) returns:

```{python}
#| echo: false
new_df = df[ df["Enrl"]<=100 ]
show_df( new_df )
```
:::

## Projection Operation in Relational Algebra

The projection operation retrieves specific columns from a relation. It enables focusing on certain attributes while discarding others, making it a key operation in relational queries.

::: {.guide-block-left}

**Π - Projection operator**

- Projection reduces the relation to specific columns (attributes).
- Denoted as Π(attribute1, attribute2,...)(Relation).
- It's used to eliminate unnecessary or redundant data.
- Like selection, projection is a unary operation.
- Projection also drops duplicate records (SQL doesn't!)!
- Projection can be combined with other operations for complex queries.
:::
::: {.guide-block-right}
**Examples**

1. Π(ID,Course):

2. Π(Course):

3. Π(Term):

4. Π(Term,ID):

:::

*Projection helps streamline query results by focusing on relevant attributes.*

### Definition of projection

::: {.guide-block-left}
**Definition**
$$
\pi_{A_1, A_2, \dots, A_n}(R) = \{ t[A_1, A_2, \dots, A_n] \mid t \in R \}
$$

* where $t$ is a row in $R$,
* $A_1, A_2, \dots, A_n$ are the attributes (columns) of relation \(R\),
* The projection operator returns a new relation containing only the specified attributes \(A_1, A_2, \dots, A_n\) from \(R\),
* The resulting relation may contain duplicate rows, which are usually removed in standard relational algebra (i.e., it becomes a set rather than a multiset).
:::
::: {.guide-block-right}

***Explanation***

- The projection operator \(\pi\) selects certain columns (attributes) from the relation \(R\), discarding the others.
- It operates by returning only the specified columns for each tuple (row) in \(R\), effectively creating a "vertical slice" of the relation.
- Duplicate tuples in the result are eliminated to ensure the output is a valid set.

:::

### Properties of projection

* **Idempotent** – Projection can be applied multiple times without side effects:

$$
\pi_{A_1, A_2, \dots, A_n}( \pi_{A_1, A_2, \dots, A_n}(R) ) = \pi_{A_1, A_2, \dots, A_n}(R)
$$

* **Commutative** – The order of projection on overlapping sets of attributes doesn't matter:

$$
\pi_{A_1, A_2}( \pi_{A_2, A_3}(R) ) = \pi_{A_2}( \pi_{A_1, A_3}(R) )
$$

  (if $A_1$, $A_2$, and $A_3$ are overlapping or compatible)

* **Non-distributive** – Projection does **not** distribute over selection, but it interacts in specific ways:
  
  - **Projection over selection** (you can select first, then project):
  
  $$
  \pi_{A_1, A_2}( \sigma_{B}(R) ) = \pi_{A_1, A_2}(R) \quad \text{if } B \text{ involves only attributes } A_1, A_2
  $$
  
  - **Selection over projection** (you cannot project first if selection involves non-projected attributes):
  
  $$
  \sigma_{B}( \pi_{A_1, A_2}(R) ) \quad \text{undefined if } B \text{ involves attributes not in } A_1, A_2
  $$


### Explanation of Properties

- **Idempotent**: Reapplying projection on the same set of attributes does not change the result. Once the attributes are reduced, further projection on the same set will not alter the relation.
- **Commutative**: When projecting on overlapping or compatible sets of attributes, the order of application does not matter (the resulting attributes will still be the same).
- **Non-distributive**: Unlike selection, projection cannot be freely distributed over operations such as selection, because projection limits the available attributes. It must respect the interaction between available attributes and conditions in the selection.

### Projection - Π - Example 1

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Π(ID,Course) returns:

```{python}
#| echo: false
new_df = df[ ["ID","Course"] ]
show_df( new_df, width="50%" )
```
:::


### Projection - Π - Example 2

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Π(Course) returns:

```{python}
#| echo: false
new_df = df[ ["Course"] ]
show_df( new_df, width="50%" )
```
:::

### Projection - Π - Example 3

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Π(Term) returns:

```{python}
#| echo: false
new_df = df[ ["Term"] ]
show_df( new_df, width="50%" )
```
:::

### Projection - Π - Example 4

::: {.guide-block-left}
Given the *Courses(ID,Course,Term,Enrl)* below:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Π(Term,ID) returns:

```{python}
#| echo: false
new_df = df[ ["Term","ID"] ]
show_df( new_df, width="50%" )
```
:::

## Union Operation in Relational Algebra

```{python}
#| echo: false
d1 = {
    'Course': ['CMSC301', 'CMSC408',  'CMSC408'],
    'Term': ['Fall 2024','Fall 2024', 'Fall 2023'],
}
d2 = {
    'Course': ['CMSC110', 'CMSC201',  'CMSC475', 'CMSC408'],
    'Term': ['Fall 2024','Fall 2024', 'Fall 2023','Fall 2024'],
}
d3 = {
   'Term': ['Fall 2022','Fall 2023','Fall 2024'],
   'Term_code': ['202310','202410','202510']
}

df1 = pd.DataFrame( d1 )
df2 = pd.DataFrame( d2 )
df3 = pd.DataFrame( d3 )

```

The union operation combines tuples from two relations, eliminating duplicates. It's an essential set operation in relational algebra, used for merging query results.

::: {.guide-block-left}
**∪ - Union Operator**

- Union combines two relations into a single relation.
- Both relations must be union-compatible (same number of attributes and domains).
- Denoted as R ∪ S.
- Duplicates are automatically removed from the result.
- Union is a binary operation, meaning it operates on two relations.
:::
::: {.guide-block-right}
**Examples**

1. *Courses1* ∪ *Courses2*

2. *Courses1* ∪ *Courses3*


:::

*The union operation enables the merging of datasets in a relational context.*

### Definition of Union Operator

::: {.guide-block-left}
**Definition**

$$
R_1 \cup R_2 = \{ t \mid t \in R_1 \text{ or } t \in R_2 \}
$$

* where $t$ is a row (tuple),
* $R_1$ and $R_2$ are relations (tables) with the same attributes,
* The union operation returns a new relation containing all distinct rows that are present in either $R_1$, $R_2$, or both,
* Duplicate rows are eliminated in the result, ensuring the output is a set, not a multiset.

:::
::: {.guide-block-right}
:::

### Properties of Union

* **Idempotent** – Applying the union of a relation with itself doesn't change the result:

$$
R \cup R = R
$$

* **Commutative** – The order of relations in a union operation doesn't matter:

$$
R_1 \cup R_2 = R_2 \cup R_1
$$

* **Associative** – The grouping of union operations doesn't affect the result:

$$
(R_1 \cup R_2) \cup R_3 = R_1 \cup (R_2 \cup R_3)
$$

* **Union with an empty set** – The union of a relation with an empty set is the relation itself:

$$
R \cup \emptyset = R
$$

* **Union distributes over intersection** – The union of two relations distributes over their intersection:

$$
R_1 \cup (R_2 \cap R_3) = (R_1 \cup R_2) \cap (R_1 \cup R_3)
$$

### Explanation of Properties

- **Idempotent**: Combining a relation with itself does not add any new rows since the union eliminates duplicates.
- **Commutative**: The union is symmetric, so the order of relations does not affect the result.
- **Associative**: You can group union operations in any way, and the result will be the same.
- **Union with an empty set**: Union with an empty relation results in the original relation, as the empty set contributes no rows.
- **Distributed**: Union distributes over intersection in a way that respects the structure of both operations.


### Union - ∪ - Example 1

::: {.guide-block-left}
Given *Courses1( Course,Term)*:

```{python}
#| echo: false
show_df(df1)
```

and *Courses2( Course,Term )*:

```{python}
#| echo: false
show_df(df2)
```

:::
::: {.guide-block-right}
*Courses1* ∪ *Courses2* returns:

```{python}
#| echo: false
new_df = pd.concat( [df1, df2] )
show_df( new_df )
```
:::

## Union - ∪ - Example 2

::: {.guide-block-left}
Given *Courses1( Course,Term)*:
```{python}
#| echo: false
show_df(df1)
```
and *Courses3( Course,Term )*:
```{python}
#| echo: false
show_df(df3)
```
:::
::: {.guide-block-right}
*Courses1* ∪ *Courses3* returns:

<center>*Invalid*</center>
<p>&nbsp;</p>

Because the schema for Courses1 and Courses3 are different, that is, the number, names, and domains of the columns don't match exactly,
the two relations cannot be combined.

The term *Union Compatible* is used to describe two relations with the same number, names, and domains of columns.
:::

## Combining Selection and Projection

In real-world queries, selection and projection are often combined to both filter and reduce data. This allows for more refined and efficient query results.

In relational algebra operations can be chained, that is, the results from one operation can be directly used inside another operation.

::: {.guide-block-left}
- Suppose we have a relation Students(Name, Grade).
- Query: Π(Name)(σ(Grade > 75)(Students)).
- The result includes only the names of students with grades above 75.
- Combining operations allows for more complex and specific queries.
- Selection and projection together form the backbone of query design.

:::
::: {.guide-block-right}
- Relational operations are ordered from the inside to the outside.
- Given this query: Π(Name)(σ(Grade > 75)(Students))
   - First, the selection operation is performed, resulting in a subset of the original relation,
   - then, the projection operation is performed, reducing the number of columns in the result.

:::

*Combining operations enables precise and targeted query results in relational databases.*

```{python}
#| echo: false
# Create the Students table as a pandas DataFrame
data = {
    'ID': ['V10101','V10102','V10103','V10104'],
    'Name': ['Alice', 'Bob', 'Carol', 'Dave'],
    'Major': ['CS', 'Math', 'CS', 'Physics'],
    'GPA': [3.5, 3.8, 3.2, 3.9],
    'Grad_Year': [2024, 2023, 2025, 2023]
}

df = pd.DataFrame(data)
```
### Combined Example 1

::: {.guide-block-left}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Find the Names and GPAs of all students who are expected to graduate in 2023.

```{python}
#| echo: false
new_df = df
show_df( new_df )
```
:::


### Combined Example 2

::: {.guide-block-left}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Find the majors of all students with a GPA greater than 3.5

```{python}
#| echo: false
new_df = df
show_df( new_df )
```
:::

### Combined Example 3

::: {.guide-block-left}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:
```{python}
#| echo: false
show_df(df)
```
:::
::: {.guide-block-right}
Find the ID and Names of all students in computer science.

```{python}
#| echo: false
new_df = df
show_df( new_df )
```
:::


## Larger Reporting Systems

Relational algebra operations are commonly used in reporting systems to query data, extract insights, and generate reports. Below are examples of larger operations as applied in practice.

::: {.guide-block-left}
1. Example: Generating a list of employees eligible for a bonus.
   - Selection operation to filter eligible employees based on criteria (e.g., performance).
   - Projection to display only relevant fields (e.g., Name, Department).
   - Union to combine results from different departments.

2. Example: Generating a report of products sold by specific vendors.
   - Selection to filter products by vendor ID.
   - Projection to display product name and vendor details.
   - Cartesian product to cross-reference products with vendor data.

:::
::: {.guide-block-right}

3. Example: Compiling a list of employees not assigned to any projects.
   - Anti-join to find employees not in the project assignment table.
   - Projection to show employee names and departments.
   - Set difference to exclude employees with assignments from the employee list.

4. Example: Producing a report of sales trends over time.
   - Selection to filter sales data by date range.
   - Aggregation to calculate sales totals by month or quarter.
   - Join to merge sales data with product or category details.

:::

Note that these examples introduce additional operators to complement the *Selection*, *Projection* and *Union* already discussed.  That's what we'll discuss next!

## Larger Reporting Systems

On the preceding slide:

* Each of these examples is considered a *single query* even though they contains multiple single relational operations.

* Your semester long project must document 20 unique queries.  To accomplish this, you'll need plenty of entities (tables).

## Conclusion: Mastering Basic Relational Algebra

Understanding the basic operations of relational algebra is crucial for working with relational databases. These operations enable effective data querying, filtering, and combination.

::: {.guide-block-left}
- Selection, projection, and union are foundational operations.
- Each operation serves a specific purpose in querying relational data.
- Combining operations enables more complex and powerful queries.
- Mastering these operations is essential for advanced database management.
- Relational algebra forms the core of SQL and other query languages.
:::
::: {.guide-block-right}
:::

*Mastering relational algebra is key to becoming proficient in database management and query design.*
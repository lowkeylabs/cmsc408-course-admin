<!-- # Basic Operations -->



## Introduction to Relational Algebra


Relational algebra is a formal system for manipulating relations, foundational for querying relational databases. This section introduces the core principles and significance of relational algebra in database systems.

```{=html}
<style>
.guide-block-right .quarto-float-fig {
  float: right;
  margin-left: 15px;
  margin-bottom: 15px;
}
</style>
```


:::: {.columns}
::: {.column width=47%}
- Relational algebra is a procedural query language.
- It provides the formal foundation for relational database operations.
- Operations in relational algebra manipulate sets of tuples.
- The basic operations include ***selection***, ***projection***, and ***union***.
- Understanding relational algebra is crucial for effective query optimization.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
![](./assets/relational-algebra-overview.jpg){fig-align="center" width=25% .lightbox .quarto-float-fig}
:::
::::


<!-- -->

*Relational algebra underpins the structure and functionality of modern relational databases.*

```{python}
#| echo: false
import pandas as pd
from tabulate import tabulate
from IPython.display import display, Markdown, HTML

# Define the DataFrame
data = {
    'ID': [1, 2, 3, 4, 5],
    'Course': ['CMSC301', 'CMSC408', 'CMSC445', 'CMSC475', 'CMSC408'],
    'Term': ['Fall 2024','Fall 2024','Fall 2024','Fall 2024','Fall 2023'],
    'Enrl': [220, 175, 37, 128, 125]
}

df = pd.DataFrame(data)

def select_rows(df, column, value):
    # Filter the DataFrame based on the given column and value
    return df[df[column] == value]

def show_df( df, width="80%" ):
#   display(Markdown(df.to_markdown(index=False)))
#   print("<center>")
#   print(tabulate(df, headers='keys', tablefmt='pretty', showindex=False))   
#   print("</center>")
   html_table = df.drop_duplicates().to_html(index=False)

   # Define the HTML with centered table and 75% width
   html_content = f"""
   <div style="text-align: center;">
      <div style="display: inline-block; width: {width};">
         {html_table}
      </div>
   </div>
"""
   display(HTML(html_content))

```



## Selection Operation in Relational Algebra


The selection operation retrieves rows from a relation that meet specified conditions. It allows narrowing down data based on predicates, forming a key part of querying in relational databases.


:::: {.columns}
::: {.column width=47%}
**σ - Selection (sigma)**

- Selection filters rows based on a condition (predicate).
- The result includes only those tuples that satisfy the predicate.
- Denoted as σ(condition)(Relation)
- It's a unary operation, meaning it operates on a single relation.
- The result of a selection can be used as input into subsequent operations.
- Selection is often used in conjunction with other operations like projection.
- *condition* can contain any relational operator (e.g., =, \<, >=, etc.)
:::
::: {.column width=6%}
:::
::: {.column width=47%}
**Unicode examples**

Below are examples of what these statement will look like on the Canvas quiz.

1. σ(ID=3)(Courses)

1. σ(Course='CMSC408')(Courses)

1. σ(Enrl\<=100)(Courses)
:::
::::


<!-- -->



## Properties of the selection operator



:::: {.columns}
::: {.column width=47%}
**Definition**

$$
\sigma_{\rho}(R) = { t \mid t \in R \text{ and } \rho(t) == \text{true} }
$$

- where $t$ is a row in $R$,
- $\rho$ (the *predicate*) is a boolean expression that evaluates true or false for all rows in $R$,
- $\rho$ consists of one or more *terms* connected by $\land$(and), $\lor$(or), $\neg$(not) function.
- *Terms* in $\rho$ are simple relational expressions evaluated using $=$, $\ne$, $\<$, $>$, $\le$, $\ge$.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
**Properties**

- *Idempotent* - can be applied multiple times without side effects:

$$
\sigma_{A}(R) = \sigma_{A} ( \sigma_{A}(R) )
$$

- *Commutative* - the order of application doesn't matter:

$$
\sigma_{A}( \sigma_{B}(R) ) = \sigma_{B}( \sigma_{A}(R) )
$$

- *Distributed* - operations can be subdivided and combined

$$
\begin{aligned}
\sigma_{A \land B}( R ) &= \sigma_{A}(R) \cap \sigma_{B}(R) \
&= \sigma_{A}( \sigma_{B}(R) ) = \sigma_{B}( \sigma_{A}(R) ) \
\sigma_{A \lor B}( R ) &= \sigma_{A}(R) \cup \sigma_{B}(R)
\end{aligned}
$$
:::
::::


<!-- -->



## Selection - σ - Example 1



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df( df )
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
σ(ID=3)(Courses) returns:

```{python}
#| echo: false
new_df = select_rows(df,"ID",3 )
show_df( new_df )
```
:::
::::


<!-- -->



## Selection - σ - Example 2



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
σ(Course='CMSC408')(Courses) returns:

```{python}
#| echo: false
new_df = select_rows(df,"Course","CMSC408" )
show_df( new_df )
```
:::
::::

<!-- -->

#

## Selection - σ - Example 3



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
σ(Enrl\<=100)(Courses) returns:

```{python}
#| echo: false
new_df = df[ df["Enrl"]<=100 ]
show_df( new_df )
```
:::
::::


<!-- -->



## Projection Operation in Relational Algebra


The projection operation retrieves specific columns from a relation. It enables focusing on certain attributes while discarding others, making it a key operation in relational queries.


:::: {.columns}
::: {.column width=47%}
**Π - Projection operator**

- Projection reduces the relation to specific columns (attributes).
- Denoted as Π(attribute1, attribute2,...)(Relation).
- It's used to eliminate unnecessary or redundant data.
- Like selection, projection is a unary operation.
- Projection also drops duplicate records (SQL doesn't!)!
- Projection can be combined with other operations for complex queries.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
**Examples**

Given a relation *Courses(ID,Course,Term,Enrl)*, the following are valid unicode examples of projection:

1. Π(ID,Course)(Courses):

1. Π(Course)(Courses):

1. Π(Term)(Courses):

1. Π(Term,ID)(Courses):
:::
::::

<!-- -->

*Projection helps streamline query results by focusing on relevant attributes.*



## Definition of projection



:::: {.columns}
::: {.column width=47%}
**Definition**
$$
\pi_{A_1, A_2, \dots, A_n}(R) = { t\[A_1, A_2, \dots, A_n\] \mid t \in R }
$$

- where $t$ is a row in $R$,
- $A_1, A_2, \dots, A_n$ are the attributes (columns) of relation (R),
- The projection operator returns a new relation containing only the specified attributes $A_1, A_2, \dots, A_n$ from $R$,
- The resulting relation may contain duplicate rows, which are usually removed in standard relational algebra (i.e., it becomes a set rather than a multiset).
:::
::: {.column width=6%}
:::
::: {.column width=47%}
***Explanation***

- The projection operator $\pi$ selects certain columns (attributes) from the relation $R$, discarding the others.
- It operates by returning only the specified columns for each tuple (row) in $R$, effectively creating a "vertical slice" of the relation.
- Duplicate tuples in the result are eliminated to ensure the output is a valid set.
:::
::::

<!-- -->



## Properties of projection


- **Idempotent** – Projection can be applied multiple times without side effects:

$$
\pi_{A_1, A_2, \dots, A_n}( \pi_{A_1, A_2, \dots, A_n}(R) ) = \pi_{A_1, A_2, \dots, A_n}(R)
$$

- **Commutative** – The order of projection on overlapping sets of attributes doesn't matter:

$$
\pi_{A_1, A_2}( \pi_{A_2, A_3}(R) ) = \pi_{A_2}( \pi_{A_1, A_3}(R) )
$$

(if $A_1$, $A_2$, and $A_3$ are overlapping or compatible)

- **Non-distributive** – Projection does **not** distribute over selection, but it interacts in specific ways:

  - **Projection over selection** (you can select first, then project):

  $$
  \pi_{A_1, A_2}( \sigma_{B}(R) ) = \pi_{A_1, A_2}(R) \quad \text{if } B \text{ involves only attributes } A_1, A_2
  $$

  - **Selection over projection** (you cannot project first if selection involves non-projected attributes):

  $$
  \sigma_{B}( \pi_{A_1, A_2}(R) ) \quad \text{undefined if } B \text{ involves attributes not in } A_1, A_2
  $$



## Explanation of Properties


- **Idempotent**: Reapplying projection on the same set of attributes does not change the result. Once the attributes are reduced, further projection on the same set will not alter the relation.
- **Commutative**: When projecting on overlapping or compatible sets of attributes, the order of application does not matter (the resulting attributes will still be the same).
- **Non-distributive**: Unlike selection, projection cannot be freely distributed over operations such as selection, because projection limits the available attributes. It must respect the interaction between available attributes and conditions in the selection.



## Projection - Π - Example 1



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Π(ID,Course)(Courses) returns:

```{python}
#| echo: false
new_df = df[ ["ID","Course"] ]
show_df( new_df, width="50%" )
```
:::
::::

<!-- -->

#

## Projection - Π - Example 2



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Π(Course)(Courses) returns:

```{python}
#| echo: false
new_df = df[ ["Course"] ]
show_df( new_df, width="50%" )
```
:::
::::

<!-- -->

#

## Projection - Π - Example 3



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Π(Term)(Courses) returns:

```{python}
#| echo: false
new_df = df[ ["Term"] ]
show_df( new_df, width="50%" )
```
:::
::::

<!-- -->

#

## Projection - Π - Example 4



:::: {.columns}
::: {.column width=47%}
Given the *Courses(ID,Course,Term,Enrl)* below:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Π(Term,ID)(Courses) returns:

```{python}
#| echo: false
new_df = df[ ["Term","ID"] ]
show_df( new_df, width="50%" )
```
:::
::::

<!-- -->



## Union Operation in Relational Algebra


```{python}
#| echo: false

d1 = {
    'Course': ['CMSC301', 'CMSC408',  'CMSC408'],
    'Term': ['Fall 2024','Fall 2024', 'Fall 2023'],
}
d2 = {
    'Course': ['CMSC110', 'CMSC201',  'CMSC475', 'CMSC408'],
    'Term': ['Fall 2024','Fall 2024', 'Fall 2023','Fall 2024'],
}
d3 = {
   'Term': ['Fall 2022','Fall 2023','Fall 2024'],
   'Term_code': ['202310','202410','202510']
}

df1 = pd.DataFrame( d1 )
df2 = pd.DataFrame( d2 )
df3 = pd.DataFrame( d3 )

```

The union operation combines tuples from two relations, eliminating duplicates. It's an essential set operation in relational algebra, used for merging query results.


:::: {.columns}
::: {.column width=47%}
**∪ - Union Operator**

- Union combines two relations into a single relation.
- Both relations must be union-compatible (same number of attributes and domains).
- Denoted as R ∪ S.
- Duplicates are automatically removed from the result.
- Union is a binary operation, meaning it operates on two relations.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
```{python}
#| echo: false
import matplotlib.pyplot as plt
from matplotlib_venn import venn2
plt.figure(figsize=(5,2.5),facecolor="none")

# Define the two sets
set_A = {1, 2, 3, 4}
set_B = {4, 5, 6, 7}

# Create the Venn diagram with custom colors
venn = venn2([set_A, set_B], set_labels=('Set A', 'Set B'))

# Set all patches to 'lightblue' color
for subset in ('10', '01', '11'):
    venn.get_patch_by_id(subset).set_color('lightblue')
    venn.get_patch_by_id(subset).set_edgecolor('black')  # Thin black borders
    venn.get_patch_by_id(subset).set_linewidth(1.5)      # Adjust the border width

# Remove the default labels for A and B
venn.get_label_by_id('10').set_text('')
venn.get_label_by_id('01').set_text('')
venn.get_label_by_id('11').set_text('')

# Make the background transparent
plt.gca().set_facecolor('none')

# Display the plot
plt.title('A ∪ B')
plt.show()

```

**Examples**

1. *Courses1* ∪ *Courses2*

1. *Courses1* ∪ *Courses3*
:::
::::

<!-- -->

*The union operation enables the merging of datasets in a relational context.*



## Definition of Union Operator



:::: {.columns}
::: {.column width=98%}
**Definition**

$$
R_1 \cup R_2 = { t \mid t \in R_1 \text{ or } t \in R_2 }
$$

- where $t$ is a row (tuple),
- $R_1$ and $R_2$ are relations (tables) with the same attributes,
- The union operation returns a new relation containing all distinct rows that are present in either $R_1$, $R_2$, or both,
- Duplicate rows are eliminated in the result, ensuring the output is a set, not a multiset.
:::
::: {.column width=1%}
:::
::: {.column width=1%}

:::
::::

<!-- -->



## Properties of Union


- **Idempotent** – Applying the union of a relation with itself doesn't change the result:

$$
R \cup R = R
$$

- **Commutative** – The order of relations in a union operation doesn't matter:

$$
R_1 \cup R_2 = R_2 \cup R_1
$$

- **Associative** – The grouping of union operations doesn't affect the result:

$$
(R_1 \cup R_2) \cup R_3 = R_1 \cup (R_2 \cup R_3)
$$

- **Union with an empty set** – The union of a relation with an empty set is the relation itself:

$$
R \cup \emptyset = R
$$

- **Union distributes over intersection** – The union of two relations distributes over their intersection:

$$
R_1 \cup (R_2 \cap R_3) = (R_1 \cup R_2) \cap (R_1 \cup R_3)
$$



## Explanation of Properties


- **Idempotent**: Combining a relation with itself does not add any new rows since the union eliminates duplicates.
- **Commutative**: The union is symmetric, so the order of relations does not affect the result.
- **Associative**: You can group union operations in any way, and the result will be the same.
- **Union with an empty set**: Union with an empty relation results in the original relation, as the empty set contributes no rows.
- **Distributed**: Union distributes over intersection in a way that respects the structure of both operations.



## Union - ∪ - Example 1



:::: {.columns}
::: {.column width=47%}
Given *Courses1( Course,Term)*:

```{python}
#| echo: false
show_df(df1)
```

and *Courses2( Course,Term )*:

```{python}
#| echo: false
show_df(df2)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
*Courses1* ∪ *Courses2* returns:

```{python}
#| echo: false
new_df = pd.concat( [df1, df2] )
show_df( new_df )
```
:::
::::

<!-- -->



## Union - ∪ - Example 2



:::: {.columns}
::: {.column width=47%}
Given *Courses1( Course,Term)*:

```{python}
#| echo: false
show_df(df1)
```

and *Courses3( Course,Term )*:

```{python}
#| echo: false
show_df(df3)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
*Courses1* ∪ *Courses3* returns:

<center>*Invalid*</center>
<p>&nbsp;</p>

Because the schema for Courses1 and Courses3 are different, that is, the number, names, and domains of the columns don't match exactly,
the two relations cannot be combined.

The term *Union Compatible* is used to describe two relations with the same number, names, and domains of columns.
:::
::::

<!-- -->



## Combining Selection and Projection


In real-world queries, selection and projection are often combined to both filter and reduce data. This allows for more refined and efficient query results.

In relational algebra operations can be chained, that is, the results from one operation can be directly used inside another operation.


:::: {.columns}
::: {.column width=47%}
- Suppose we have a relation Students(Name, Grade).
- Query: Π(Name)(σ(Grade > 75)(Students)).
- The result includes only the names of students with grades above 75.
- Combining operations allows for more complex and specific queries.
- Selection and projection together form the backbone of query design.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
- Relational operations are ordered from the inside to the outside.
- Given this query: Π(Name)(σ(Grade > 75)(Students))
  - First, the selection operation is performed, resulting in a subset of the original relation,
  - then, the projection operation is performed, reducing the number of columns in the result.
:::
::::

<!-- -->

*Combining operations enables precise and targeted query results in relational databases.*

```{python}
#| echo: false
# Create the Students table as a pandas DataFrame
data = {
    'ID': ['V10101','V10102','V10103','V10104'],
    'Name': ['Alice', 'Bob', 'Carol', 'Dave'],
    'Major': ['CS', 'Math', 'CS', 'Physics'],
    'GPA': [3.5, 3.8, 3.2, 3.9],
    'Grad_Year': [2024, 2023, 2025, 2023]
}

df = pd.DataFrame(data)
```



## Combined Example 1



:::: {.columns}
::: {.column width=47%}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Find the Names and GPAs of all students who are expected to graduate in 2023.

Π(Name,GPA)(σ(Grad_Year=2023)(Students))

```{python}
#| echo: false
new_df = df[ df["Grad_Year"]==2023][["Name","GPA"]]
show_df( new_df )
```
:::
::::

<!-- -->



## Combined Example 2



:::: {.columns}
::: {.column width=47%}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Find the majors of all students with a GPA greater than 3.5

Π(Major)(σ(GPA>3.5)(Students))

```{python}
#| echo: false
new_df = df
new_df = df[ df["GPA"]>3.5][["Major"]]
show_df( new_df )
```
:::
::::

<!-- -->



## Combined Example 3



:::: {.columns}
::: {.column width=47%}
Given *Students( ID,Name,Major,GPA,Grad_Year)*:

```{python}
#| echo: false
show_df(df)
```
:::
::: {.column width=6%}
:::
::: {.column width=47%}
Find the ID and Names of all students in computer science.

Π(ID,Name)(σ(Major=CS)(Students))

```{python}
#| echo: false
new_df = df
new_df = df[ df["Major"]=='CS'][["ID","Name"]]
show_df( new_df )
```
:::
::::

<!-- -->



## Larger Reporting Systems


Relational algebra operations are commonly used in reporting systems to query data, extract insights, and generate reports. Below are examples of larger operations as applied in practice.


:::: {.columns}
::: {.column width=47%}
1. Example: Generating a list of employees eligible for a bonus.

   - Selection operation to filter eligible employees based on criteria (e.g., performance).
   - Projection to display only relevant fields (e.g., Name, Department).
   - Union to combine results from different departments.

1. Example: Generating a report of products sold by specific vendors.

   - Selection to filter products by vendor ID.
   - Projection to display product name and vendor details.
   - Cartesian product to cross-reference products with vendor data.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
3. Example: Compiling a list of employees not assigned to any projects.

   - Anti-join to find employees not in the project assignment table.
   - Projection to show employee names and departments.
   - Set difference to exclude employees with assignments from the employee list.

1. Example: Producing a report of sales trends over time.

   - Selection to filter sales data by date range.
   - Aggregation to calculate sales totals by month or quarter.
   - Join to merge sales data with product or category details.
:::
::::

<!-- -->

Note that these examples introduce additional operators to complement the *Selection*, *Projection* and *Union* already discussed.  That's what we'll discuss next!



## Larger Reporting Systems


On the preceding slide:

- Each of these examples is considered a *single query* even though they contains multiple single relational operations.

- Your semester long project must document 20 unique queries.  To accomplish this, you'll need plenty of entities (tables).



## Larger Reporting Systems


Relational algebra operations are commonly used in reporting systems to query data, extract insights, and generate reports. Below are examples of larger operations as applied in practice.


:::: {.columns}
::: {.column width=47%}
1. Example: Generating a list of employees eligible for a bonus.

   - Selection operation to filter eligible employees based on criteria (e.g., performance).
   - Projection to display only relevant fields (e.g., Name, Department).
   - Union to combine results from different departments.

1. Example: Generating a report of products sold by specific vendors.

   - Selection to filter products by vendor ID.
   - Projection to display product name and vendor details.
   - Cartesian product to cross-reference products with vendor data.
:::
::: {.column width=6%}
:::
::: {.column width=47%}
3. Example: Compiling a list of employees not assigned to any projects.

   - Anti-join to find employees not in the project assignment table.
   - Projection to show employee names and departments.
   - Set difference to exclude employees with assignments from the employee list.

1. Example: Producing a report of sales trends over time.

   - Selection to filter sales data by date range.
   - Aggregation to calculate sales totals by month or quarter.
   - Join to merge sales data with product or category details.
:::
::::

<!-- -->

Note that these examples introduce additional operators to complement the *Selection*, *Projection* and *Union* already discussed.  That's what we'll discuss next!



## Larger Reporting Systems


On the preceding slide:

- Each of these examples is considered a *single query* even though they contains multiple single relational operations.

- Your semester long project must document 20 unique queries.  To accomplish this, you'll need plenty of entities (tables).



## Conclusion: Mastering Basic Relational Algebra


Understanding the basic operations of relational algebra is crucial for working with relational databases. These operations enable effective data querying, filtering, and combination.


:::: {.columns}
::: {.column width=98%}
- Selection, projection, and union are foundational operations.
- Each operation serves a specific purpose in querying relational data.
- Combining operations enables more complex and powerful queries.
- Mastering these operations is essential for advanced database management.
- Relational algebra forms the core of SQL and other query languages.
:::
::: {.column width=1%}
:::
::: {.column width=1%}

:::
::::

<!-- -->

*Mastering relational algebra is key to becoming proficient in database management and query design.*



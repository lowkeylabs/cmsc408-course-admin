
# SELECT statement

## SELECT clause

:::: {.columns}
::: {.column width=50%}
A *SELECT* query is the one of the most fundamental
statements in SQL.

A *SELECT* statement describe a request to perform operations within the database and return a *result set*.  

This *result set* is a relation.

This *result* can be used in subsequent operations or stored back into the DB as a new table.

A SQL query is relational algebra:

$\Pi_{A_1, A_2, ... A_n}(\sigma_{P}(R_1 \times R_2 \times ... \times R_n) )$

:::
::: {.column width=50%}
**SELECT** A1, A2, A3

**FROM** R1,R2

**WHERE** P

**ORDER BY** A2,A3,A1

* A* represents an attribute (column), a literal, a function, or an operation
* R* represents a relation (table), cartesian project, or join
* P is a predicate, conditions or filters

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}

* The select clause lists the attributes desired in the result of a query, corresponds to the projection operation of the relational algebra

* SQL names are case insensitive

* SQL allows duplicates in relations as well as in query results

* To force the elimination of duplicates, use the keyword distinct

* An asterisk in the select clause denotes “all attributes”

* May rename columns using alias

:::
::: {.column width=50%}

-- this is syntax
SELECT [distinct] {*, column [[as] alias], ...}
FROM table {or tables}

-- this is a real statement (and comment!)
SELECT
  *
FROM
  REGIONS

-- indents are not managed
-- comments stop processing of line


:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### Using * to select all columns
result = pd.read_sql("""
select * from regions
""",cnx)
result

:::
::: {.column width=50%}
### Selecting only one attribute
result = pd.read_sql("""
select
  region_name
from
  regions
""",cnx)
result

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### Gathering all last names
result = pd.read_sql("""
select last_name from employees
""",cnx)
result

:::
::: {.column width=50%}
### Eliminating duplicates with DISTINCT
result = pd.read_sql("""
select distinct last_name from employees
""",cnx)
result

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### Combining last and first names
result = pd.read_sql("""
select concat(last_name,',',first_name)
from employees
""",cnx)
result.head(7)

:::
::: {.column width=50%}
### Then renaming the column
result = pd.read_sql("""
select concat(last_name,',',first_name) as full_name
from employees
""",cnx)
result.head(7)

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### attribute can be literal or function

result = pd.read_sql("""

select
  27 as "Literal",
  now() as "Current Time" 
from
  dual

""",cnx)
result.head(7)
<p>&nbsp;</p>
Note that we're using a built-in table named *dual* that 
returns what you put in as a table that can be used
in subsequent operations.

:::
::: {.column width=50%}
### Doing computations

The attribute can be a function or arithmetic operation
result = pd.read_sql("""
select concat(last_name,',',first_name) as full_name,
salary*12 as "Annual Salary"
from employees
""",cnx)
result.head(5)

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}

* The WHERE clause specifies conditions that the results must satisfy, correspoding to the $\sigma$ predicate in relational algebra.

* An individual WHERE element returns TRUE or FALSE for every row.  This is applied during the query and will return only rows that evaluate TRUE in the where clause.

* Attributes in where clause can be compared using relational operators: <  <=  =  >=  >
* WHERE elements can be combined using *AND*, *OR* and *NOT* logical operators.

* WHERE also uses special operators: *BETWEEN*, *IN* and *IS NULL*

:::
::: {.column width=50%}

result = pd.read_sql("""
-- note that this is a monthly salary!
SELECT
  last_name, first_name, salary
FROM
  employees
WHERE
  salary > 10000
""",cnx)
result.head(5)


:::
::::




## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### Selecting a department
result = pd.read_sql("""
select last_name,department_id
from employees
where department_id=110;
""",cnx)
result.head(7)
<p>&nbsp;</p>
Data types matter.  You'll get an error
if you set *department_id='110'*

:::
::: {.column width=50%}
### Using BETWEEN
The attribute can be a function or arithmetic operation
result = pd.read_sql("""
select concat(last_name,',',first_name) as full_name, salary
from employees
where salary BETWEEN 10000 and 12000;
""",cnx)
result.head(5)

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### Using IN
result = pd.read_sql("""
select last_name,department_id
from employees
where department_id in (100,145,146)
""",cnx)
result.head(7)
<p>&nbsp;</p>

:::
::: {.column width=50%}
### The long way
result = pd.read_sql("""
select last_name,department_id
from employees
where department_id=30 or department_id=70 or department_id=120
""",cnx)
result
<p>&nbsp;</p>

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### What are all the department IDs?
result = pd.read_sql("""
select distinct department_id
from employees
order by department_id
""",cnx)
result
<p>&nbsp;</p>

:::
::: {.column width=50%}
### Who is missing a manager?
result = pd.read_sql("""
select last_name,job_id,manager_id
from employees
where manager_id is NULL
""",cnx)
result.head(7)
<p>&nbsp;</p>

NULL must be all caps!!

:::
::::

## Computations

:::: {.columns}
::: {.column width=50%}
### Calculating commissions
#| echo: true
#| eval: false
result = pd.read_sql("""

select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  12.0*salary+commission_pct*salary as "With/Commission"
from
  employees
order by
  last_name,
  first_name

""",cnx)
result
<p>&nbsp;</p>
What are the NaN "not a number" entries?

How do we remove the NaN (not a number) from
list? 

:::
::: {.column width=50%}
### Calculating commissions
#| echo: false
#| eval: true
result = pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  12.0*salary+commission_pct*salary as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
result
:::
::::

## IFNULL operator

:::: {.columns}
::: {.column width=50%}
### The IFNULL operator

IFNULL( expr1, expr2 ) replaces NULL with a value.

* IF expr1 is NOT NULL then returns expr1

* IF expr1 IS NULL, then returns expr2.

:::
::: {.column width=50%}
### Calculating commissions
#| echo: true
#| eval: false
result = pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,0.0) as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
result
:::
::::

## IFNULL operator

:::: {.columns}
::: {.column width=50%}
### IFNULL( expr1, 0.0)
#| echo: false
#| eval: true
result = pd.read_sql("""

select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,0.0) as "With/Commission"
from
  employees
order by
  last_name,
  first_name

""",cnx)
result
:::
::: {.column width=50%}
### IFNULL( expr1, 'missing')
#| echo: false
#| eval: true
result = pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,'missing') as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
result
:::
::::

## String operations

The operator *LIKE* uses patterns (case insensitive) (use *LIKE BINARY* for case sensitive) for string-matching operations using two special characters:

    * percentage ( % ) matches any substring (none or many characters)
    * underscore ( _ ) matches any single character

Examples:

'Intro%' 		matches any string beginning with “Intro”

'%Comp%' 	matches any string containing “Comp” as a substring

'_ _ _' 		matches any string of exactly three characters

'_ _ _ %' 		matches any string of at least three characters

'%_ a _ ' 		same as before but the second to the last letter is 'a'

## String operations

:::: {.columns}
::: {.column width=50%}
### DOUBLE %% when using Python
#| echo: true
#| eval: true
result = pd.read_sql("""
select last_name from employees
where last_name like 'MC%%'
""",cnx)
result
:::
::: {.column width=50%}
### DOUBLE %% when using Python
#| echo: true
#| eval: true
result = pd.read_sql("""
SELECT phone_number FROM employees
WHERE phone_number LIKE '%%123%%';
""",cnx)
result
:::
::::

## ORDER BY clause

:::: {.columns}
::: {.column width=50%}
*ORDER BY* is used to specify
the sort order in the result set.

The result set is sorted by the first attribute listed in the *ORDER BY*.

If there is a tie, *ORDER BY* moves to the second attribute, and so on.

Attribute expression may be modified with ASC (the default) or DESC (for descending)

Attributes in *ORDER BY* can be computed!

:::
::: {.column width=50%}
### Example
#| echo: true
#| eval: true
result = pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Full Name", salary as "Monthly"
from employees
order by
  salary desc,
  last_name, first_name
""",cnx)
result
:::
::::

## Housekeeping

- Focus on getting everything to work!
- YES - you MUST be able render explore.qmd. 

#| echo: false
from src.utils import upcoming_calendar
# Set the lecture ID and number of rows to show at the top of this file!
upcoming_calendar( lecture_id, n_rows )

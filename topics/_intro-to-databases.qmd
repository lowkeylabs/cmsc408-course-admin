# A long time ago ... in a galaxy far, far away ...

## Early history

:::: {.columns}

::: {.column}
### 1950s and early 1960s:
* Data processing using [magnetic tapes for storage](https://en.wikipedia.org/wiki/Magnetic-tape_data_storage)
* Tapes provided only sequential access
* [Punched cards for input](https://en.wikipedia.org/wiki/Punched_card_input/output)
:::
::: {.column width="40%"}
![](assets/1951_TapeData_P2.jpg)
:::
::::

<center><em>The history of databases tracks the history of computers</em></center>

## Early history

:::: {.columns}
::: {.column}
### Late 1960s and 1970s:
* [Hard disks allowed](https://en.wikipedia.org/wiki/History_of_hard_disk_drives) direct access to data
* [Network and hierarchical data models](https://en.wikipedia.org/wiki/Database_model) in widespread use
* [Edgar "Ted" Codd](https://en.wikipedia.org/wiki/Edgar_F._Codd) defines the Relational data model
* [High-performance (for the era) transaction processing](https://en.wikipedia.org/wiki/Transaction_processing)
:::
::: {.column width="40%"}
![](assets/1970-IBM_2314_DiskDrives_and_IBM_2540_CardReader_Punch.jpg)
:::
::::

<center><em>The history of databases tracks the history of computers</em></center>

## Modern systems

:::: {.columns}
:::{.column}
### 1980s:

* Research relational prototypes evolve into commercial systems
    - SQL becomes industrial standard
* Parallel and distributed database systems
* Object-oriented database systems

### 1990s:

* Large decision support and data-mining applications
* Large multi-terabyte data warehouses
* Emergence of Web commerce
:::
::: {.column}
![](assets/1990-computer-center.png)
:::
::::

<center><em>The history of databases tracks the history of computers</em></center>

## Modern systems

:::: {.columns}
::: {.column}
### Early 2000s:

* XML and XQuery standards
* Automated database administration

### Later 2000s:

* Giant data storage systems
* Google BigTable, Yahoo PNuts, Amazon, â€¦

### 2022 and Beyond:

<https://cacm.acm.org/magazines/2022/8/262905-the-seattle-report-on-database-research/fulltext#body-4>
:::
::: {.column}
![](assets/google-data-center.png)
:::
::::

## [Open Source Data Engineering Landscape 2024](https://practicaldataengineering.substack.com/p/open-source-data-engineering-landscape){target="_blank"}

![](assets/data-engineering-landscape-2024.png){.lightbox}

## [Open Source Data Engineering Landscape 2024](https://practicaldataengineering.substack.com/p/open-source-data-engineering-landscape){target="_blank"}

![](assets/data-engineering-landscape-2024-with-highlights.png){.lightbox}


## Why not use spreadsheets?

### Spreadsheets DO work and they ARE viable!

:::: {.columns}
::: {.column}
[Here is spreadsheet driven web site](https://vcu-ssg.github.io/ssg-quarto-cmsc-courses/)
:::
::: {.column}
[Here is the spreadsheet](https://docs.google.com/spreadsheets/d/1qrN3L7eRLsM-aVMHYaLQN-FMYtrTJf0_h6dLKlUdPkk/edit#gid=107368023)
:::
::::

### On the surface spreadsheets share many common elements with databases

:::: {.columns}
::: {.column}
### Entities
* *Worksheets* are *Tables*
* *Rows* are sometimes *Records*
* *Columns* are sometimes *Fields*
* *Workbooks* are *Databases* (collections of tables)
:::
::: {.column}
### Operations
* find rows, insert rows, delete rows, update rows,
* add columns, remove columns
* create worksheets, delete worksheets
* create workbooks, delete workbooks
:::
::::

## Why not use spreadsheets?

### Drawbacks of using files and workbooks store data

* Data redundancy and inconsistency in multiple files and formats
* Difficulty in accessing data: where and how
* Data isolation
* Integrity problems and constraints
* Atomicity of updates
* Concurrent access by multiple users
* Security problems

## On Line Transaction Processing (OLTP) databases

:::: {.columns}
::: {.column width=80%}

::: {.more-separation}
* This semester we'll be working with OLTP databases, like MySQL, Postgres, SQLITE, Oracle, DB2 and SQLServer.

* These are *Relational* databases, that is, the database stores entities and the relationships between these entities.

* These databases log each change to the database as a transaction.  Groups of transactions can be reviewed and used to restore the database to an earlier state.

* Transactions (changes to the database) are communicated to the database management system using a language called *SQL*, a *structured query language*.

* [How do I pronounce SQL?](https://www.youtube.com/watch?v=S9C8PNX72Ms)

:::

:::
::: {.column width=20%}
![](assets/oltp-snip.png)
:::
::::

## On Line Transaction Processing (OLTP) databases

:::: {.columns}
::: {.column}

- **Fast Query Processing:** These databases prioritize quick query response times to ensure efficient and prompt processing of individual transactions, making them ideal for applications like banking, e-commerce, and order management systems.

- **High Transaction Volume:** OLTP databases are designed to handle a large number of short, atomic transactions, such as inserting, updating, or deleting records, which are typically initiated by end-users in real-time.

:::
::: {.column}

- **Data Integrity and Consistency:** OLTP systems implement ACID (Atomicity, Consistency, Isolation, Durability) properties to ensure that all transactions are processed reliably, maintaining the integrity and consistency of the data even in the event of system failures.

- **Normalized Data Structure:** OLTP databases typically use a highly normalized schema to minimize data redundancy, optimize storage efficiency, and reduce the complexity of data manipulation during frequent transactions.

:::
::::

## CMSC 408 - in a nutshell

* We'll apply *entity-relation* models to design and describe the contents of a database.

* We'll apply *relational algebra* to formally describe how we query the database.

* We'll apply *normalization* to ensure that we minimize redundant information in the database.

* We'll tie everything together using SQL.
```{mermaid}
%%| echo: false
gantt
    dateFormat M/DD/YYYY
    axisFormat %W

    section Topics
    ER Models : m1, 1/7/2024, 3w
    Rel. Algebra: m4, after m1, 2w
    Normal forms: m5, after m4, 3w
    SQL : m6, after m5, 4w
    Adv. SQL: m7, after m6, 5w
```


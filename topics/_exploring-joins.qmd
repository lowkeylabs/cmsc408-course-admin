<!-- # Exploring Joins -->


```{python}
#| echo: false

import os
import sys
import pandas as pd
from tabulate import tabulate
from dotenv import load_dotenv
from sqlalchemy import create_engine, text, inspect
from sqlalchemy.exc import ArgumentError, NoSuchModuleError, OperationalError, ProgrammingError

def run_sql_and_return_df(sql, cnx):
    """Given an SQL command and connection string, return a DataFrame."""

    # Check if the connection is None
    if cnx is None:
        error_message = "No valid connection. See above."
        df = pd.DataFrame({'ErrorType': ['ConnectionError'], 'ErrorMessage': [error_message]})
        return df.to_html(index=False)

    try:
        df = pd.read_sql(sql, cnx)
        if df.empty:
            # Create a single-row DataFrame with all columns as None
            df = pd.DataFrame([["no records returned"]+ [''] * (len(df.columns) - 1) ], columns=df.columns)

        # Convert the DataFrame to HTML and use custom styling to span columns if needed
        html_output = df.to_html(index=False, na_rep="", justify="center")

        # Add colspan attribute to span columns if rendering in an environment that supports it
        html_output = html_output.replace('<td>no records found</td>', f'<td colspan="{len(df.columns)}">no records found</td>')
        return html_output

    except OperationalError as e:
        # Catch connection or database errors
        error_message = f"Operational Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['OperationalError'], 'ErrorMessage': [error_message]})
    except ProgrammingError as e:
        # Catch SQL syntax errors or issues with the command
        error_message = f"Programming Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['ProgrammingError'], 'ErrorMessage': [error_message]})
    except mysql.connector.Error as e:
        # Catch MySQL-specific errors
        error_message = f"MySQL Connector Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['MySQL Connector Error'], 'ErrorMessage': [error_message]})
    except Exception as e:
        # Catch all other exceptions
        error_message = f"Unknown Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['UnknownError'], 'ErrorMessage': [error_message]})
    
    return df.to_html(index=False)

def create_database_engine(uri):
    """Create an SQLAlchemy engine with error handling and test the connection."""

    try:
        # Attempt to create the engine
        engine = create_engine(uri)

        # Test the connection with a lightweight query

        run_sql_and_return_df("select 1 from dual",engine)

#        with engine.connect() as connection:
#            connection.execute(text("SELECT 1"))
        
        return engine  # Return the engine if connection test is successful

    except sqlalchemy.exc.ArgumentError as e:
        error_message = f"URI Error: {e}"
    except sqlalchemy.exc.NoSuchModuleError as e:
        error_message = f"Database driver not found: {e}"
    except sqlalchemy.exc.OperationalError as e:
        error_message = f"Operational error: {e}"
    except Exception as e:
        error_message = f"An unexpected error occurred: {e}"
    
    return None  # Return None if any error occurs

from sqlalchemy.exc import OperationalError, ProgrammingError
import pandas as pd

from sqlalchemy.exc import OperationalError, ProgrammingError
import pandas as pd
import re

def run_ddl_and_confirm(sql, cnx):
    """Given a DDL SQL command with multiple statements and connection, confirm execution or return an error message in HTML format."""

    if cnx is None:
        error_message = "No valid connection. See above."
        df = pd.DataFrame({'ErrorType': ['ConnectionError'], 'ErrorMessage': [error_message]})
        return df.to_html(index=False)

    # Split the SQL statements by ";" while ignoring empty statements
    statements = [stmt.strip() for stmt in re.split(r';\s*', sql) if stmt.strip()]

    try:
        with cnx.begin() as connection:
            for statement in statements:
                connection.execute(text(statement))
        
        # Confirm successful execution
        df = pd.DataFrame({'Status': ['Success'], 'Message': ['All DDL commands executed successfully']})
        # return df.to_html(index=False)
        return None

    except OperationalError as e:
        error_message = f"Operational Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['OperationalError'], 'ErrorMessage': [error_message]})
    except ProgrammingError as e:
        error_message = f"Programming Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['ProgrammingError'], 'ErrorMessage': [error_message]})
    except Exception as e:
        error_message = f"Unknown Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['UnknownError'], 'ErrorMessage': [error_message]})
    
    return df.to_html(index=False)


def execute_ddl_from_file(filename, cnx):
    """
    Executes DDL statements from a file on a given SQLAlchemy connection, 
    capturing any errors and results.
    """
    messages = []
    errors = []

    with open(filename, 'r', encoding='utf-8') as file:
        ddl_commands = file.read()

    # Split commands if needed, such as if commands are separated by semicolons
    ddl_statements = [cmd.strip() for cmd in ddl_commands.split(';') if cmd.strip()]

    with cnx.connect() as connection:
        for statement in ddl_statements:
            try:
                result = connection.execute(text(statement))
                # Capture the result, if any
                result_info = result.rowcount if result.rowcount != -1 else "No rows affected"
                messages.append(f"Executed statement: {statement}<br/>Result: {result_info}<br/>")
            except Exception as e:
                # Capture the error message if execution fails
                errors.append(f"<hr/>Error executing statement: <b>{statement}</b><br/>    Error: {str(e)}<br/>")

    return messages, errors

```

```{python}
#| echo: false

# modify config_map to reflect credentials needed by this program
# These variables are set in your .env file
config_map = {
    'user':'CMSC408_USER',
    'password':'CMSC408_PASSWORD',
    'host':'CMSC408_HOST',
    'database':'HW6_DB_NAME'
}
# load and store credentials
load_dotenv()
config = {}
for key in config_map.keys():
    config[key] = os.getenv(config_map[key])

errors = []
for param in config.keys():
    if config[param] is None:
        flag = True
        errors.append(f"Missing {config_map[param]} in .env file.")

cnx = None
error_df=""
if errors:
    errors.append("All subsequent SQL commands will fail.")
    errors.append("Fix the .env file and rerun quarto ...")
    # Convert errors to a DataFrame
    error_df = pd.DataFrame({'Errors loading .env file': errors})
    error_df
else:
# build a sqlalchemy engine string
    engine_uri = f"mysql+pymysql://{config['user']}:{config['password']}@{config['host']}/{config['database']}"

    # create and test the database connection.
    cnx = create_database_engine( engine_uri )


```


## Exploring Joins - a sandbox schema

:::: {.columns}
::: {.column width=50%}
### Sandbox schema

```{sql}
drop table if exists peopleskills;
drop table if exists people;
create table people (
    id int,
    name varchar(20) NOT NULL,
    primary key(id)
);
insert into people (id,name) values
( 101,'Omar'),
( 102,'Layla'),
( 103,'Alex');

drop table if exists skills;
create table skills (
    id int primary key,
    name varchar(20) NOT NULL
);
insert into skills (id,name) values
( 201,'Jumping'),
( 202,'Skipping'),
( 203,'Coding')
;
```
```{python}
#| echo: false
sql = """
drop table if exists peopleskills;
drop table if exists people;
create table people (
    id int,
    name varchar(20) NOT NULL,
    primary key(id)
);
insert into people (id,name) values
( 101,'Omar'),
( 102,'Layla'),
( 103,'Alex');

drop table if exists skills;
create table skills (
    id int primary key,
    name varchar(20) NOT NULL
);
insert into skills (id,name) values
( 201,'Jumping'),
( 202,'Skipping'),
( 203,'Coding')
;
commit;
"""
##df = run_sql_and_return_df( sql,cnx )
run_ddl_and_confirm( sql, cnx)
```

:::
::: {.column width=50%}
### Sample Schema

* People - contains a simple ID and name

* Skills - contains a simple ID and name

### Notes

* I PURPOSEFULLY am using the same field names in each table.  This will force us to more carefully specify fields in our queries.

* I suggest that you try these commands in VS Code.

* Note that you may already have tables using the same names in your existing schema!  You need to delete the old tables to clear out the entire schema.

* When deleting old tables, look out for foreign key constraint errors.  
:::
::::

## Exploring Joins - the data

### Quick look *people*
:::: {.columns}
::: {.column}
```{sql}
select * from people
```
:::
::: {.column}
```{python}
#| echo: false
sql = f"""
select * from people;
"""
run_sql_and_return_df( sql,cnx )
```
:::
::::

### Quick look *skills*
:::: {.columns}
::: {.column}
```{sql}
select * from skills
```
:::
::: {.column}
```{python}
#| echo: false
sql = f"""
select * from skills;
"""
run_sql_and_return_df( sql,cnx )
```
:::
::::

## Exploring Joins - cross-products

### A cross-product join (no ON)
:::: {.columns}
::: {.column}
```{sql}
select
  *
from
  people a, skills b
```
### Notes

* the `*` returns all fields across all tables without having to name them.

* Returns all combinations of records across both tables

* Note that the names match in these slides.
:::
::: {.column}
```{python}
#| echo: false
sql = f"""
select
  *
from
  people, skills
"""
run_sql_and_return_df( sql,cnx )
```
:::
::::

## Exploring Joins - connecting people and skills

:::: {.columns}
::: {.column}
### How do we associate people and skills?

<p>&nbsp;</p>
A key part of database design is properly translating
our ER diagrams to SQL.

We spent lots of time talking about *cardinality* and *participation*,
that is, how different entities connect to each other.

Learning how to represent *cardinality* and *participation* in
SQL is critical to your success as a database engineer1.

We've been using *keys* to make these connections in our ER diagrams.

:::
::: {.column}

### Cardinalty and Participation

Think about our options for connecting people and skills.

* A person MUST have one and only one skill.

* A person may have one skill or no skills.

* A person can have many skills (more than one).

How would you code these instances in SQL?

:::
::::

## Exploring Joins - connect people to skills

:::: {.columns}
::: {.column width=60%}
### Using a field to contain the id of the skill

```{sql}
drop table if exists people;
create table people (
    id int primary key,
    name varchar(20) NOT NULL,
    skill_id int NULL
);

```
* FOREIGN KEY specifier isn't necessary
* NULL or NOT NULL specifies none-or-one or exactly-one

### Adding a FOREIGN KEY helper

```{sql}
drop table if exists people;
create table people (
    id int primary key,
    name varchar(20) NOT NULL,
    skill_id int NOT NULL,
    foreign key (skill_id) references skills(id)
);

```
* FOREIGN KEY is a helper that will manage
relationships between the two tables
* Foreign key statement will ensure skills_id always
points to an existing skill.

:::
::: {.column width=40%}
```{mermaid}
erDiagram
    PEOPLE {
        int id PK
        varchar name
        int skill_id FK
    }

    SKILLS {
        int id PK
        varchar name
    }

    PEOPLE o|..|o SKILLS : "has"
```

### In this example ...

People keeps track of their skill.

Skills doesn't *know* anything about people.
:::
::::


## Exploring Joins - connect people to skills

:::: {.columns}
::: {.column}
### Adding none-or-one skills
```{sql}
drop table if exists people;
create table people (
    id int primary key,
    name varchar(20) NOT NULL,
    skills_id int NULL,
    foreign key (skills_id) references skills(id)
      on delete set NULL
      on update cascade
);
insert into people (id,name, skills_id) values
( 101,'Omar', 201),
( 102,'Layla', NULL),
( 103,'Alex', 203);
```
### Notes

* We're adding *skills_id* to people so that each
person can track none-or-one skills.

* The *foreign key* constraint tells the database what happens
to the *skills_id* field when the matching record
in *skills* is changed.

:::
::: {.column}

```{python}
#| echo: false
sql = f"""
drop table if exists peopleskills;
drop table if exists people;
drop table if exists skills;
create table skills (
    id int primary key,
    name varchar(20) NOT NULL
);
insert into skills (id,name) values
( 201,'Jumping'),
( 202,'Skipping'),
( 203,'Coding');
create table people (
    id int primary key,
    name varchar(20) NOT NULL,
    skills_id int NULL,
    foreign key (skills_id) references skills(id)
      on delete set NULL
      on update cascade
);
insert into people (id,name, skills_id) values
( 101,'Omar', 201),
( 102,'Layla', NULL),
( 103,'Alex', 203);
"""
#df = run_sql_and_return_df( sql,cnx )
run_ddl_and_confirm( sql, cnx )
```
### Who has what skills?
```{sql}
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    join skills on (people.skills_id = skills.id )
```

<p>&nbsp;</p>

```{python}
sql = """
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    join skills on (people.skills_id = skills.id )
order by
  people.id
"""
run_sql_and_return_df( sql,cnx )
```

### Notes

Wait - aren't there 3 people?  Where is person 102?

:::
::::



## Exploring Joins - Inner vs Left

:::: {.columns}
::: {.column}
### Who has what skills? (INNER JOIN)

```{sql}
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    INNER JOIN skills on (people.skills_id = skills.id )
```

<p>&nbsp;</p>

```{python}
#| echo: false
sql = """
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    INNER JOIN skills on (people.skills_id = skills.id )
order by
  people.id
"""
run_sql_and_return_df( sql,cnx )

```

### Notes

* `INNER JOIN` only returns records that match in BOTH 
tables.  If no match, nothing is returned.
:::
::: {.column}

### Who has what skills? (LEFT JOIN)
```{sql}
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    LEFT JOIN skills on (people.skills_id = skills.id )
```

<p>&nbsp;</p>

```{python}
#| echo: false
sql = """
select
  people.id,
  people.name,
  people.skills_id,
  skills.id,
  skills.name
from
  people 
    LEFT JOIN skills on (people.skills_id = skills.id )
order by
  people.id
"""
run_sql_and_return_df( sql,cnx )

```

### Notes

* The `LEFT JOIN` requires that all records from the first (left) table MUST 
be listed at least once.
* If no match, then NULL values are returned in fields.
:::
::::

## Exploring Joins - One-to-many in SQL

Moving from `none-to-one` to `one-to-many` requires a helper table.

:::: {.columns}
::: {.column width=50%}

### None-to-One

To model this case, we added a foreign key
directly into the *people* table.

```{sql}
drop table if exists people;
create table people (
    id int primary key,
    name varchar(20) NOT NULL,
    skill_id int NOT NULL,
    foreign key (skill_id) references skills(id)
);

```

### Notes

* This approach pollutes the people table. It now contains
non-people related information.

* We can only have non-or-one skills.

* How can we have more than one skill?


:::
::: {.column}
### One to Many

To model MANY we add a helper (join) table that serves
to associate people and skills.

```{sql}
drop table if exists peopleskills;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);
```

### Notes

* We remove any skills references from people, unpolluting it.

* We associate people with skills through this table.

* More records means MANY connections.

:::
::::

## Exploring Joins - One-to-Many in SQL

:::: {.columns}
::: {.column}
### Creating the helper table

```{sql}
drop table if exists peopleskills;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);

insert into peopleskills (people_id,skills_id) values 
(101, 201),
(103, 203);

```

:::
::: {.column}
### Using the join helper table

```{python}
#| echo: false
#| exec: true
sql = """
drop table if exists peopleskills;
commit;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);
insert into peopleskills (people_id,skills_id) values 
(101, 201),
(103, 203);

"""
#df = run_sql_and_return_df( sql,cnx )
run_ddl_and_confirm( sql, cnx )
```

```{sql}
select 
  peopleskills.*,
  people.name,
  skills.name
from
  peopleskills
    join people on (peopleskills.people_id=people.id)
    join skills on (peopleskills.skills_id=skills.id);
```

<p>&nbsp;</p>

```{python}
#| echo: false
sql = """
select 
  peopleskills.*,
  people.name,
  skills.name
from
  peopleskills
    join people on (peopleskills.people_id=people.id)
    join skills on (peopleskills.skills_id=skills.id)
;
"""
run_sql_and_return_df( sql,cnx )
```

:::
::::


## Exploring Joins - One-to-Many in SQL

:::: {.columns}
::: {.column}
### Adding multiple skills

```{sql}
drop table if exists peopleskills;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);

insert into peopleskills (people_id,skills_id) values 
(101, 201),
(101, 202),
(103, 201),
(103, 203);

```

### Notes

* To add multiple skills, we add nore `people-skill` pairs.


:::
::: {.column}
### Using the helper table

```{python}
#| echo: false
#| exec: true
sql = """
drop table if exists peopleskills;
drop table if exists people;
create table people (
    id int,
    name varchar(20) NOT NULL,
    primary key(id)
);
insert into people (id,name) values
( 101,'Omar'),
( 102,'Layla'),
( 103,'Alex');
drop table if exists skills;
create table skills (
    id int primary key,
    name varchar(20) NOT NULL
);
insert into skills (id,name) values
( 201,'Jumping'),
( 202,'Skipping'),
( 203,'Coding');
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);
insert into peopleskills (people_id,skills_id) values 
(101, 201),
(101, 202),
(103, 201),
(103, 203);
"""
#df = run_sql_and_return_df( sql,cnx )
run_ddl_and_confirm( sql, cnx )
```

```{sql}
select 
  peopleskills.*,
  people.name,
  skills.name
from
  peopleskills
    join people on (peopleskills.people_id=people.id)
    join skills on (peopleskills.skills_id=skills.id);
```

<p>&nbsp;</p>

```{python}
#| echo: false
sql = """
select 
  peopleskills.*,
  people.name,
  skills.name
from
  peopleskills
    join people on (peopleskills.people_id=people.id)
    join skills on (peopleskills.skills_id=skills.id)
;
"""
run_sql_and_return_df( sql,cnx )
```

:::
::::


## Exploring Joins - Enforcing participation

:::: {.columns}
::: {.column}
### One-to-One

```{sql}
drop table if exists peopleskills;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL UNIQUE,
    skills_id int NOT NULL UNIQUE,
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);

insert into peopleskills (people_id,skills_id) values 
(101, 201),
(101, 202),
(103, 201),
(103, 203);

```

### Notes

* Using `UNIQUE` on `people_id` or `skills_id` enforces
that only one value can exist in the `peopleskills` table.

* The `INSERT` statement above will throw errors because
of the duplicate `101`, `103` and `201` values.

:::
::: {.column}

### Preventing duplicate pairs

```{sql}
drop table if exists peopleskills;
create table peopleskills (
    id int auto_increment primary key,
    people_id int NOT NULL,
    skills_id int NOT NULL,
    UNIQUE (people_id, skills_id),
    foreign key (people_id) references people(id)
      on delete cascade on update cascade,
    foreign key (skills_id) references skills(id)
      on delete cascade on update cascade
);

insert into peopleskills (people_id,skills_id) values 
(101, 201),
(101, 202),
(101, 201);

```

### Notes

* Using `UNIQUE` keyword on multiple values, tells the
DBMS to check and toss an error if duplicate `pairs` are found.

* This is enforced on INSERTs and UPDATES.

* The `INSERT` statement will throw an error on `101-201`


:::
::::

## Exploring Joins

* A Join table is the preferred way to model relationships in SQL.

* Using appropriate modifiers `NULL`, `NOT NULL`, and `UNIQUE` we can model:
    * One-to-One,
    * None to One,
    * One to Many relationships

* Keeping connections in a join table minimizes pollution in the primary tables.


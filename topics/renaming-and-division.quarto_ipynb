{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "format:\n",
        "  revealjs:\n",
        "    include-in-header:\n",
        "    - text: <script src='https://toolness.github.io/p5.js-widget/p5-widget.js'></script>\n",
        "title: Renaming and Division\n",
        "---\n",
        "\n",
        "\n",
        "# Renaming and Division\n",
        "\n",
        "\n",
        "\n",
        "## Renaming in Relational Algebra\n",
        "\n",
        "\n",
        "Renaming allows the assignment of new names to relations or attributes, making complex queries easier to understand. This operation helps avoid ambiguities, especially in self-joins or when handling multiple relations.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Renaming provides a way to assign new names to relations and their attributes.\n",
        "- The `ρ` (rho) operator is used for renaming in relational algebra.\n",
        "- Syntax: `ρ(new_name(old_name))` for renaming relations.\n",
        "- Renaming is essential when performing self-joins to avoid confusion.\n",
        "- It allows for clearer queries when dealing with complex or long attribute names.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Renaming enhances clarity in query design, especially when handling multiple relations.*\n",
        "\n",
        "Here’s the definition and properties of the **renaming** operation in relational algebra, formatted similarly to the template you provided:\n",
        "\n",
        "\n",
        "\n",
        "## Properties of the Renaming Operator\n",
        "\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=47%}\n",
        "**Definition**\n",
        "\n",
        "$$\n",
        "\\rho_{new_name}(R) = { t \\mid t \\in R }\n",
        "$$\n",
        "\n",
        "- where $R$ is a relation (table),\n",
        "- $new_name$ is the new name assigned to relation $R$ or one or more of its attributes,\n",
        "- The **renaming** operation is used to assign a new name to either the entire relation or to individual attributes in the relation, preserving the structure and data,\n",
        "- It allows us to avoid ambiguity in cases where relations have overlapping attribute names or when working with complex queries.\n",
        "\n",
        "The renaming operation can be used in three forms:\n",
        "\n",
        "- Renaming the entire relation: $\\rho_{S}(R)$ renames relation $R$ to $S$,\n",
        "- Renaming attributes: $\\rho_{(A_1 \\rightarrow B_1, A_2 \\rightarrow B_2, \\dots)}(R)$ renames the attributes $A_1, A_2, \\dots$ in $R$ to $B_1, B_2, \\dots$,\n",
        "- Renaming both the relation and its attributes: $\\rho_{S(A_1 \\rightarrow B_1, A_2 \\rightarrow B_2, \\dots)}(R)$.\n",
        ":::\n",
        "::: {.column width=6%}\n",
        ":::\n",
        "::: {.column width=47%}\n",
        "**Properties**\n",
        "\n",
        "- **Idempotent** – Renaming a relation or attribute multiple times with the same name does not change the result:\n",
        "\n",
        "$$\n",
        "\\rho_{new_name}(\\rho_{new_name}(R)) = \\rho_{new_name}(R)\n",
        "$$\n",
        "\n",
        "- **Non-commutative** – The order of renaming different attributes matters:\n",
        "\n",
        "$$\n",
        "\\rho_{(A \\rightarrow B)}(\\rho_{(B \\rightarrow C)}(R)) \\neq \\rho_{(B \\rightarrow C)}(\\rho_{(A \\rightarrow B)}(R))\n",
        "$$\n",
        "\n",
        "- **Associative** – Renaming operations can be grouped without affecting the result:\n",
        "\n",
        "$$\n",
        "\\rho_{new_name_1}(\\rho_{new_name_2}(R)) = \\rho_{new_name_2}(\\rho_{new_name_1}(R))\n",
        "$$\n",
        "\n",
        "- **Renaming with an empty set** – Renaming an empty relation still results in an empty set:\n",
        "\n",
        "$$\n",
        "\\rho_{new_name}(\\emptyset) = \\emptyset\n",
        "$$\n",
        "\n",
        "- **Renaming preserves all rows and attributes** – The renaming operation only changes names and does not affect the content or structure of the relation:\n",
        "\n",
        "$$\n",
        "|R| = |\\rho_{new_name}(R)|\n",
        "$$\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "\n",
        "\n",
        "## Explanation of properties\n",
        "\n",
        "\n",
        "- **Idempotent**: Renaming a relation or attribute multiple times with the same name has no additional effect.\n",
        "- **Non-commutative**: The order in which you rename attributes matters, especially if the renaming involves the same attribute multiple times.\n",
        "- **Associative**: Renaming operations can be applied in any order, provided they refer to different attributes or relation names.\n",
        "- **Renaming with an empty set**: If the relation is empty, renaming it will still result in an empty relation.\n",
        "- **Renaming preserves all rows and attributes**: The renaming operation only affects the labels of relations and attributes, not their content or structure, so the number of rows and attributes remains unchanged.\n",
        "\n",
        "\n",
        "\n",
        "## Example of Renaming in Queries\n",
        "\n",
        "\n",
        "Renaming becomes critical when performing operations like joins, ensuring that attribute names are distinct. This slide provides a simple renaming example to illustrate its importance.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Example: `ρ(S(Age -> StudentAge))` renames the attribute `Age` to `StudentAge` in relation `S`.\n",
        "- Used to avoid name clashes during operations such as joins.\n",
        "- Provides a way to clarify attribute roles in a query.\n",
        "- Enables more readable queries in complex databases.\n",
        "- Essential when working with relations that have identical attribute names.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Renaming is a flexible tool for improving query readability and structure.*\n",
        "\n",
        "\n",
        "\n",
        "## Introduction to Division in Relational Algebra\n",
        "\n",
        "\n",
        "Division is a specialized relational operation used to retrieve tuples that match all combinations of a related set. It is particularly useful when you need to find records related to every value in another relation.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Division is used to query for entities that are related to all values in a subset.\n",
        "- The operation works on two relations: a dividend and a divisor.\n",
        "- It returns tuples from the dividend that are associated with all tuples in the divisor.\n",
        "- Typically used in \"all\" queries, such as \"students enrolled in all courses.\"\n",
        "- Not as common as basic operations but vital in certain query types.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Division is a powerful but specific operation that allows querying for \"all related\" records.*\n",
        "\n",
        "\n",
        "\n",
        "## Properties of the Division Operator\n",
        "\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=47%}\n",
        "**Definition**\n",
        "\n",
        "$$\n",
        "R_1 \\div R_2 = { t_1 \\mid t_1 \\in \\pi_{A}(R_1) \\text{ and for every } t_2 \\in R_2, (t_1, t_2) \\in R_1 }\n",
        "$$\n",
        "\n",
        "- where $R_1$ is a relation with attributes $A \\cup B$,\n",
        "- $R_2$ is a relation with attributes $B$ (a subset of $R_1$'s attributes),\n",
        "- The **division** operation returns a new relation consisting of the values of $A$ from $R_1$ that match every tuple in $R_2$,\n",
        "- Essentially, division finds the tuples in $R_1$ that have a corresponding match for every tuple in $R_2$.\n",
        ":::\n",
        "::: {.column width=6%}\n",
        ":::\n",
        "::: {.column width=47%}\n",
        "**Properties**\n",
        "\n",
        "- **Not commutative** – The order of relations in the division operation matters:\n",
        "\n",
        "$$\n",
        "R_1 \\div R_2 \\neq R_2 \\div R_1\n",
        "$$\n",
        "\n",
        "- **Non-associative** – Division is not associative:\n",
        "\n",
        "$$\n",
        "(R_1 \\div R_2) \\div R_3 \\neq R_1 \\div (R_2 \\div R_3)\n",
        "$$\n",
        "\n",
        "- **Division with an empty set** – If $R_2$ is an empty set, the division result is the projection of $R_1$ on $A$:\n",
        "\n",
        "$$\n",
        "R_1 \\div \\emptyset = \\pi_{A}(R_1)\n",
        "$$\n",
        "\n",
        "- **Division with itself** – Dividing a relation by itself results in an empty set unless $R_2$ contains only tuples present in $R_1$:\n",
        "\n",
        "$$\n",
        "R_1 \\div R_1 = \\emptyset \\quad \\text{(if } R_1 \\text{ and } R_2 \\text{ are identical and non-empty)}\n",
        "$$\n",
        "\n",
        "- **Division with a superset** – If $R_2$ is a superset of $B$-values in $R_1$, the result is empty:\n",
        "\n",
        "$$\n",
        "R_1 \\div R_2 = \\emptyset \\quad \\text{(if } \\pi_B(R_2) \\not\\subseteq \\pi_B(R_1))\n",
        "$$\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "\n",
        "\n",
        "## Explanation:\n",
        "\n",
        "\n",
        "- **Not commutative**: The order of relations in the division operation matters, as dividing one relation by another is not symmetric.\n",
        "- **Non-associative**: Division is not associative, meaning that the order in which you perform multiple division operations can affect the result.\n",
        "- **Division with an empty set**: If $R_2$ is empty, the result is the projection of $R_1$ on $A$, as no conditions exist for $B$ attributes.\n",
        "- **Division with itself**: Dividing a relation by itself typically results in an empty set unless all tuples from $R_2$ are in $R_1$.\n",
        "- **Division with a superset**: If $R_2$ contains values that don't appear in $R_1$, the result is empty since no $A$-values in $R_1$ satisfy the matching condition for all tuples in $R_2$.\n",
        "\n",
        "\n",
        "\n",
        "## Division: Syntax and Example\n",
        "\n",
        "\n",
        "Division can be represented using the `/` operator between two relations. Understanding how this operator works in practice will help you apply it correctly.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Syntax: `R / S` where `R` is the dividend and `S` is the divisor.\n",
        "- Example: Find students enrolled in all mandatory courses: `StudentCourses / MandatoryCourses`.\n",
        "- Involves projecting attributes from `R` that do not appear in `S`.\n",
        "- Often paired with set difference to exclude unwanted tuples.\n",
        "- Typically used when one relation defines a subset of another relation’s attributes.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*The division operator retrieves records that match a complete set of conditions across relations.*\n",
        "\n",
        "Here’s the **division** relational operator example using the template format you provided earlier:"
      ],
      "id": "16f35695"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "data_customers = {\n",
        "    'CustomerID': ['C001', 'C001', 'C002', 'C002', 'C002', 'C003'],\n",
        "    'DishID': ['D001', 'D002', 'D001', 'D002', 'D003', 'D001']\n",
        "}\n",
        "customers = pd.DataFrame(data_customers)\n",
        "\n",
        "data_dimsum = {\n",
        "    'DishID': ['D001', 'D002', 'D003'],\n",
        "    'DishName': ['Siu Mai', 'Har Gow', 'Char Siu Bao']\n",
        "}\n",
        "dimsum = pd.DataFrame(data_dimsum)"
      ],
      "id": "c35d5cec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Division - ÷ - Example\n",
        "\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=47%}\n",
        "Given *Customers(CustomerID, DishID)*:"
      ],
      "id": "611c551a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "show_df(customers)"
      ],
      "id": "5bfd3039",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "and *DimSum(DishID, DishName)*:"
      ],
      "id": "6754f27d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "show_df(dimsum)"
      ],
      "id": "f14a3ff2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "::: {.column width=6%}\n",
        ":::\n",
        "::: {.column width=47%}\n",
        "Find the customers who have ordered all dim sum dishes:"
      ],
      "id": "9d4dd4ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "# First, group by CustomerID and find the unique DishID each customer has ordered\n",
        "customer_orders = customers.groupby('CustomerID')['DishID'].apply(set).reset_index()\n",
        "\n",
        "# Get the set of all dim sum dishes\n",
        "all_dimsum_dishes = set(dimsum['DishID'])\n",
        "\n",
        "# Filter customers who have ordered all dim sum dishes\n",
        "customers_with_all_dimsum = customer_orders[customer_orders['DishID'].apply(lambda x: all_dimsum_dishes.issubset(x))]\n",
        "\n",
        "# Show the resulting customers\n",
        "show_df(customers_with_all_dimsum[['CustomerID']])"
      ],
      "id": "c6f3dce9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This query performs a **division** operation to find customers who have ordered **all** the dim sum dishes listed in the `DimSum` table. The result shows only those customers (in this case, `CustomerID: C002`) who have ordered all available dishes.\n",
        "\n",
        "- The `CustomerID` of the customer(s) who ordered every dim sum dish (from the `DimSum` table) will be displayed.\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "\n",
        "\n",
        "## Practical Use Case for Division\n",
        "\n",
        "\n",
        "Division is especially useful in scenarios where a tuple needs to be related to all tuples in another relation, such as students attending all classes or employees assigned to all projects.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Example: \"Find suppliers who supply all products in a given category.\"\n",
        "- Applicable in situations where completeness across multiple related attributes is required.\n",
        "- Helps with queries involving all relationships between a set of tuples.\n",
        "- Simplifies queries that would otherwise require multiple joins or nested operations.\n",
        "- Especially common in constraint-related queries, such as project assignments.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Division is ideal for scenarios where a record must meet all criteria in a related set.*\n",
        "\n",
        "\n",
        "\n",
        "## Common Mistakes with Division\n",
        "\n",
        "\n",
        "Although powerful, division can be misused or misunderstood, particularly in situations where its requirements aren’t fully met. This slide highlights common pitfalls to avoid.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Confusing division with joins, especially in multi-relation queries.\n",
        "- Forgetting that all tuples in the divisor must match for a result to be returned.\n",
        "- Misinterpreting the need for completeness across tuples in both relations.\n",
        "- Using division in cases where a simple join would suffice.\n",
        "- Failing to project the correct attributes before performing the operation.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Avoid these common errors to ensure the correct application of division in your queries.*\n",
        "\n",
        "\n",
        "\n",
        "## Renaming and Division in Query Design\n",
        "\n",
        "\n",
        "Combining renaming and division can lead to highly readable, efficient queries. This slide demonstrates how these operations complement each other in practice.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Renaming helps clarify relations and attributes before applying division.\n",
        "- Avoids ambiguity when the same attributes are present in both relations.\n",
        "- Ensures that division works on correctly named attributes.\n",
        "- Improves readability of queries, especially in complex database structures.\n",
        "- Example: `ρ(StudentCourses/AllCourses)` can clarify query intent and results.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Renaming can simplify and clarify the application of division in query design.*\n",
        "\n",
        "\n",
        "\n",
        "## Limitations of Division in Relational Algebra\n",
        "\n",
        "\n",
        "Division, while useful, has limitations and is not appropriate for all query types. Understanding these constraints will help avoid unnecessary complexity in queries.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Division requires exact matching across relations, which may not be flexible enough for some queries.\n",
        "- Not suitable for situations where partial matches are acceptable.\n",
        "- Can be less intuitive than other relational operations like join or projection.\n",
        "- Often difficult to optimize in large databases due to its complexity.\n",
        "- Sometimes requires preprocessing or additional operations to work effectively.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Division is powerful but limited by its strict requirements for matching across relations.*\n",
        "\n",
        "\n",
        "\n",
        "## Alternatives to Division\n",
        "\n",
        "\n",
        "In cases where division is not the best fit, other relational operations may be more appropriate. This slide explores alternatives such as joins and nested queries.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Join operations, including natural and theta joins, often provide more flexible alternatives to division.\n",
        "- Nested queries can sometimes replace division, offering more control over specific conditions.\n",
        "- Set operations like intersection and difference may achieve similar results.\n",
        "- Depending on the database design, a series of joins and selections may be more efficient.\n",
        "- SQL often handles division-like queries using alternative constructs like `HAVING` or correlated subqueries.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Consider alternatives to division when its strict requirements don't fit the query’s needs.*\n",
        "\n",
        "\n",
        "\n",
        "## Summary of Renaming and Division\n",
        "\n",
        "\n",
        "Renaming and division are important operations in relational algebra, each with its own use cases and limitations. Properly applied, these tools enhance both query design and execution.\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "::: {.column width=98%}\n",
        "- Renaming clarifies queries by giving distinct names to relations and attributes.\n",
        "- Division helps identify tuples related to all members of another relation.\n",
        "- Division is strict and requires complete matching, while renaming aids in query readability.\n",
        "- Both operations are essential for complex query design and practical database management.\n",
        "- Combining these tools can lead to clearer and more efficient relational queries.\n",
        ":::\n",
        "::: {.column width=1%}\n",
        ":::\n",
        "::: {.column width=1%}\n",
        "\n",
        ":::\n",
        "::::\n",
        "\n",
        "<!-- -->\n",
        "\n",
        "*Understanding renaming and division allows for more advanced and efficient database queries.*\n"
      ],
      "id": "48ac9476"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\jdleonard\\AppData\\Local\\pypoetry\\Cache\\virtualenvs\\cmsc427-yciDUe4a-py3.13\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
<!-- # Getting to SELECT -->

```{python}
#| echo: false

import os
import re
import sys
import copy
import pandas as pd
from itables import show
from tabulate import tabulate
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from sqlalchemy.exc import ArgumentError, NoSuchModuleError, OperationalError, ProgrammingError


def run_sql_and_return_df(cnx, sql, show_size=True):
    """Given an SQL command and connection string, return a DataFrame."""

    # Check if the connection is None
    if cnx is None:
        error_message = "No valid connection. See above."
        df = pd.DataFrame({'ErrorType': ['ConnectionError'], 'ErrorMessage': [error_message]})

    try:
        df = pd.read_sql(sql, cnx)
        if df.empty:
            # Create a single-row DataFrame with all columns as None
            df = pd.DataFrame([["no records returned"]+ [''] * (len(df.columns) - 1) ], columns=df.columns)

        df = df.replace("None","NULL")
        return df

    except OperationalError as e:
        # Catch connection or database errors
        error_message = f"Operational Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['OperationalError'], 'ErrorMessage': [error_message]})
    except ProgrammingError as e:
        # Catch SQL syntax errors or issues with the command
        error_message = f"Programming Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['ProgrammingError'], 'ErrorMessage': [error_message]})
#    except mysql.connector.Error as e:
#        # Catch MySQL-specific errors
#        error_message = f"MySQL Connector Error: {str(e)}"
#        df = pd.DataFrame({'ErrorType': ['MySQL Connector Error'], 'ErrorMessage': [error_message]})
    except Exception as e:
        # Catch all other exceptions
        error_message = f"Unknown Error: {str(e)}"
        df = pd.DataFrame({'ErrorType': ['UnknownError'], 'ErrorMessage': [error_message]})
    
    return df

def run_sql_and_return_html( cnx, sql, show_size=True):
    """ """
    df = run_sql_and_return_df( cnx, sql, show_size )

    # Convert the DataFrame to HTML and use custom styling to span columns if needed
    html_output = df.to_html(index=False, na_rep="NULL", justify="center")
    html_output = re.sub(r'\bNone\b', 'NULL', html_output)
    
    # Add colspan attribute to span columns if rendering in an environment that supports it
    html_output = html_output.replace('<td>no records found</td>', f'<td colspan="{len(df.columns)}">no records found</td>')
    
    # Append a row at the bottom with row and column count information
    if show_size and (len(df)>0):
        row_count = len(df)
        col_count = len(df.columns)
        count_row = f'<tr><td colspan="{col_count}" style="text-align: left;">Total Rows: {row_count}, Total Columns: {col_count}</td></tr>'
        html_output = html_output.replace('</tbody>', f'{count_row}</tbody>')

    return html_output

def create_database_engine(uri):
    """Create an SQLAlchemy engine with error handling and test the connection."""

    try:
        # Attempt to create the engine
        engine = create_engine(uri)

        # Test the connection with a lightweight query

        run_sql_and_return_df(engine,"select 1 from dual")

#        with engine.connect() as connection:
#            connection.execute(text("SELECT 1"))
        
        return engine  # Return the engine if connection test is successful

    except ArgumentError as e:
        error_message = f"URI Error: {e}"
    except NoSuchModuleError as e:
        error_message = f"Database driver not found: {e}"
    except OperationalError as e:
        error_message = f"Operational error: {e}"
    except Exception as e:
        error_message = f"An unexpected error occurred: {e}"
    
    return None  # Return None if any error occurs


def create_db_wrapper( config_map ):

    # load and store credentials
    load_dotenv()
    config = {}
    for key in config_map.keys():
        config[key] = os.getenv(config_map[key])

    errors = []
    for param in config.keys():
        if config[param] is None:
            flag = True
            errors.append(f"Missing {config_map[param]} in .env file.")

    cnx = None
    error_df=""
    if errors:
        errors.append("All subsequent SQL commands will fail.")
        errors.append("Fix the .env file and rerun quarto ...")
        # Convert errors to a DataFrame
        error_df = pd.DataFrame({'Errors loading .env file': errors})
        print(f"{'\n'.join(errors)}")
    else:
    # build a sqlalchemy engine string
        engine_uri = f"mysql+pymysql://{config['user']}:{config['password']}@{config['host']}/{config['database']}"

        # create and test the database connection.
        cnx = create_database_engine( engine_uri )
    return cnx,config

   

def split_sql_commands(sql):
    # Initialize default delimiter
    delimiter = ';'
    statements = []
    buffer = []

    # Split on newline to process line by line
    lines = sql.splitlines()
    
    for line in lines:
        # Check if the line is a DELIMITER command
        delimiter_match = re.match(r'^DELIMITER\s+(\S+)', line.strip(), re.IGNORECASE)
        
        if delimiter_match:
            # If there's a buffer with previous statements, join them and add to statements
            if buffer:
                statements.append(" ".join(buffer).strip())
                buffer = []
            # Set the new delimiter from DELIMITER command
            delimiter = delimiter_match.group(1)
            continue

        # Use the current delimiter to split statements
        parts = re.split(re.escape(delimiter), line)
        
        # Process all parts except the last (incomplete) part
        for part in parts[:-1]:
            buffer.append(part)
            statements.append(" ".join(buffer).strip())
            buffer = []

        # The last part may be incomplete, so add it to the buffer
        buffer.append(parts[-1])

    # Add any remaining buffer as the last statement
    if buffer:
        statements.append(" ".join(buffer).strip())
        
    return [stmt for stmt in statements if stmt]


def execute_ddl(cnx,ddl_commands):
    """
    Executes DDL statements from a file on a given SQLAlchemy connection, 
    capturing any errors and results.
    """
    messages = []
    errors = []

    # Check if the connection is None
    if cnx is None:
        error_message = "No valid connection. See above."
        df = pd.DataFrame({'ErrorType': ['ConnectionError'], 'ErrorMessage': [error_message]})
        return df.to_html(index=False)

    # Split commands if needed
    ddl_statements = split_sql_commands( ddl_commands )
#    ddl_statements = [cmd.strip() for cmd in ddl_commands.split(';') if cmd.strip()]

    with cnx.connect() as connection:
        for statement in ddl_statements:
            try:
                result = connection.execute(text(statement))
                # Capture the result, if any
                result_info = result.rowcount if result.rowcount != -1 else "No rows affected"
                messages.append(f"Executed statement: {statement}<br/>Result: {result_info}<br/>")
            except Exception as e:
                # Capture the error message if execution fails
                errors.append(f"<hr/>Error executing statement: <b>{statement}</b><br/>    Error: {str(e)}<br/>")

#    return messages, errors

    if errors:
        df = pd.DataFrame({'Errors': errors})
        return df.to_html(index=False)

    return None

# Load these variables from first .env file found.
config_map = {
  'user': "MYSQL_USERNAME",
  'password': "MYSQL_PASSWORD",
  'host': "MYSQL_DB_HOST",
  'database': "HW5_DB_NAME"
}

cnx,config = create_db_wrapper( config_map )
  
```

## Select statement

:::: {.columns}
::: {.column width=50%}
A *SELECT* query is the one of the most fundamental
statements in SQL.

A *SELECT* statement describe a request to perform operations within the database and return a *result set*.  

This *result set* is a relation.

This *result* can be used in subsequent operations or stored back into the DB as a new table.

A SQL query is relational algebra:

$\Pi_{A_1, A_2, ... A_n}(\sigma_{P}(R_1 \times R_2 \times ... \times R_n) )$

:::
::: {.column width=50%}
**SELECT** A1, A2, A3

**FROM** R1,R2

**WHERE** P

**ORDER BY** A2,A3,A1;

* A* represents an attribute (column), a literal, a function, or an operation
* R* represents a relation (table), cartesian project, or join
* P is a predicate, conditions or filters

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}

* The select clause lists the attributes desired in the result of a query, corresponds to the projection operation of the relational algebra

* SQL names are case insensitive

* SQL allows duplicates in relations as well as in query results

* To force the elimination of duplicates, use the keyword distinct

* An asterisk in the select clause denotes “all attributes”

* May rename columns using alias

:::
::: {.column width=50%}

```{sql}
-- this is syntax
SELECT [distinct] {*, column [[as] alias], ...}
FROM table {or tables}

-- this is a real statement (and comment!)
SELECT
  *
FROM
  REGIONS

-- indents are not managed
-- comments stop processing of line

```

### Want to know more?

* [See the full documentation for SELECT](https://dev.mysql.com/doc/refman/8.4/en/select.html)

:::
::::

## *Regions* table

Two different helper functions provided in homework 5: *run_sql_and_return_df* and *run_sql_and_return_html*.

:::: {.columns}
::: {.column}

::: {style="font-size: 100%;"}
```{python}
#| echo: fenced
run_sql_and_return_df(cnx,"""
select 
  *
from
  regions
""")
```
:::

:::
::: {.column}
::: {style="font-size: 100%;"}
```{python}
#| echo: fenced
run_sql_and_return_html(cnx,"""
select 
  *
from
  regions
""")
```
:::

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### Using * to select all columns
```{python}
#| echo: fenced
#| code-line-numbers: 4-4
run_sql_and_return_html(cnx,"""
select * from regions
""")
```

:::
::: {.column width=50%}
### Selecting only one attribute
```{python regions}
#| echo: fenced
#| code-line-numbers: 4-7
run_sql_and_return_html(cnx,"""
select
  region_name
from
  regions
""")
```
:::
::::


## *Employees* table - first 15 rows

::: {style="font-size:50%;"}
```{python}
#| echo: fenced
run_sql_and_return_html(cnx,"""
select * from employees limit 15
""")
```
:::

## SELECT clause and examples

:::: {.columns}
::: {.column style="width:50%;font-size:50%"}
### Gathering all last names
```{python}
#| echo: fenced
#| code-line-numbers: 4-4
df = run_sql_and_return_df(cnx,"""
select last_name from employees
""")
show(df,pageLength=6)
```

:::
::: {.column style="width:50%;font-size:50%"}
### Eliminating duplicates with DISTINCT
```{python}
#| echo: fenced
#| code-line-numbers: 4-4
df = run_sql_and_return_df(cnx,"""
select distinct last_name from employees
""")
show(df,pageLength=6)
```

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column style="width:50%;font-size:50%"}
### Combining last and first names
```{python}
#| echo: fenced
#| code-line-numbers: 4-5
df = run_sql_and_return_df(cnx,"""
select concat(last_name,',',first_name)
from employees
""")
show(df,pageLength=6)
```

:::
::: {.column style="width:50%;font-size:50%"}
### Then renaming the column
```{python}
#| echo: fenced
#| code-line-numbers: 4-5
df = pd.read_sql("""
select concat(last_name,',',first_name) as full_name 
from employees
""",cnx)
show(df,pageLength=6)
```

:::
::::

## SELECT clause and examples

:::: {.columns}
::: {.column width=50%}
### attribute can be literal or function
```{python}
#| echo: fenced
#| code-line-numbers: 4-8
pd.read_sql("""
select
  27 as "Literal",
  now() as "Current Time" 
from
  dual
""",cnx)
```
<p>&nbsp;</p>
Note that we're using a built-in table named *dual* that 
returns what you put in as a table that can be used
in subsequent operations.

:::
::: {.column width=50%}
### Doing computations

The attribute can be a function or arithmetic operation
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select concat(last_name,',',first_name) as full_name,
salary*12 as "Annual Salary"
from employees limit 5
""",cnx)
```

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}

* The WHERE clause specifies conditions that the results must satisfy, corresponding to the $\sigma$ predicate in relational algebra.

* An individual WHERE element returns TRUE or FALSE for every row.  This is applied during the query and will return only rows that evaluate TRUE in the where clause.

* Attributes in where clause can be compared using relational operators: <  <=  =  >=  >
* WHERE elements can be combined using *AND*, *OR* and *NOT* logical operators.

* WHERE also uses special operators: *BETWEEN*, *IN* and *IS NULL*

:::
::: {.column width=50%}

```{python}
#| echo: fenced
#| code-line-numbers: 5-10
pd.read_sql("""
-- note that this is a monthly salary!
SELECT
  last_name, first_name, salary
FROM
  employees
WHERE
  salary > 10000
LIMIT
  5
""",cnx)

```

:::
::::




## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### Selecting a department
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select last_name,department_id
from employees
where department_id=110 limit 7;
""",cnx)
```
<p>&nbsp;</p>
Data types matter.  You'll get an error
if you set *department_id='110'*

:::
::: {.column width=50%}
### Using BETWEEN
The attribute can be a function or arithmetic operation
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select concat(last_name,',',first_name) as full_name, salary
from employees
where salary BETWEEN 10000 and 12000
limit 5;
""",cnx)
```

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### Using IN
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select last_name,department_id
from employees
where department_id in (100,145,146)
""",cnx)
```
<p>&nbsp;</p>

:::
::: {.column width=50%}
### The long way
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select last_name,department_id
from employees
where department_id=30 or department_id=70 or department_id=120
""",cnx)
```
<p>&nbsp;</p>

:::
::::

## WHERE clause and examples

:::: {.columns}
::: {.column width=50%}
### What are all the department IDs?
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select distinct department_id
from employees
order by department_id
""",cnx)
```
<p>&nbsp;</p>

:::
::: {.column width=50%}
### Who is missing a manager?
```{python}
#| echo: fenced
#| code-line-numbers: 4-6
pd.read_sql("""
select last_name,job_id,manager_id
from employees
where manager_id is NULL
limit 7
""",cnx)
```
<p>&nbsp;</p>

NULL must be all caps!!

:::
::::

## Computations

:::: {.columns}
::: {.column width=50%}
### Calculating commissions
```{python}
#| eval: false
#| echo: fenced
#| code-line-numbers: 5-13
pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  12.0*salary+commission_pct*salary as "With/Commission"
from
  employees
order by
  last_name,
  first_name
""",cnx)
```
<p>&nbsp;</p>
What are the NaN "not a number" entries?

How do we remove the NaN (not a number) from
list? 

:::
::: {.column width=50%}
### Calculating commissions
```{python}
#| echo: false
#| eval: true
pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  12.0*salary+commission_pct*salary as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
```
:::
::::

## IFNULL operator

:::: {.columns}
::: {.column width=50%}
### The IFNULL operator

IFNULL( expr1, expr2 ) replaces NULL with a value.

* IF expr1 is NOT NULL then returns expr1

* IF expr1 IS NULL, then returns expr2.

:::
::: {.column width=50%}
### Calculating commissions
```{python}
#| eval: false
#| echo: fenced
#| code-line-numbers: 5-10
pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,0.0) as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
```
:::
::::

## IFNULL operator

:::: {.columns}
::: {.column width=50%}
### IFNULL( expr1, 0.0)
```{python}
#| echo: false
#| eval: true
pd.read_sql("""

select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,0.0) as "With/Commission"
from
  employees
order by
  last_name,
  first_name

""",cnx)
```
:::
::: {.column width=50%}
### IFNULL( expr1, 'missing')
```{python}
#| echo: false
#| eval: true
pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Name",
  salary as "Monthly",
  IFNULL(12.0*salary+commission_pct*salary,'missing') as "With/Commission"
from employees
order by last_name, first_name
""",cnx)
```
:::
::::

## String operations

The operator *LIKE* uses patterns (case insensitive) (use *LIKE BINARY* for case sensitive) for string-matching operations using two special characters:

    * percentage ( % ) matches any substring (none or many characters)
    * underscore ( _ ) matches any single character

Examples:

'Intro%' 		matches any string beginning with “Intro”

'%Comp%' 	matches any string containing “Comp” as a substring

'_ _ _' 		matches any string of exactly three characters

'_ _ _ %' 		matches any string of at least three characters

'%_ a _ ' 		same as before but the second to the last letter is 'a'

## String operations

:::: {.columns}
::: {.column width=50%}
### DOUBLE %% when using Python
```{python}
#| eval: true
#| echo: fenced
#| code-line-numbers: 5-6
pd.read_sql("""
select last_name from employees
where last_name like 'MC%%'
""",cnx)
```
:::
::: {.column width=50%}
### DOUBLE %% when using Python
```{python}
#| eval: true
#| echo: fenced
#| code-line-numbers: 5-6
pd.read_sql("""
SELECT phone_number FROM employees
WHERE phone_number LIKE '%%123%%';
""",cnx)

```
:::
::::

## ORDER BY clause

:::: {.columns}
::: {.column width=50%}
*ORDER BY* is used to specify
the sort order in the result set.

The result set is sorted by the first attribute listed in the *ORDER BY*.

If there is a tie, *ORDER BY* moves to the second attribute, and so on.

Attribute expression may be modified with ASC (the default) or DESC (for descending)

Attributes in *ORDER BY* can be computed!

:::
::: {.column width=50%}
### Example
```{python}
#| eval: true
#| echo: fenced
#| code-line-numbers: 5-10
pd.read_sql("""
select 
  concat(last_name,',',first_name) as "Full Name", salary as "Monthly"
from employees
order by
  salary desc,
  last_name, first_name
""",cnx)
```
:::
::::

## SELECT summary

:::: {.columns}
::: {.column}
### Major statement clauses

* `SELECT` - variable to project
* `FROM` - tables to combine
* `WHERE` - filters to apply
* `ORDER BY` - order of results

### Inside each clause

* `CONCAT` - combining columns
* `AS` - Renaming columns
* Literals
* Computations in SELECT

<p>&nbsp;</p>

See the [MySQL *SELECT* documentation](https://dev.mysql.com/doc/refman/8.0/en/select.html).

:::
::: {.column}
### Filters and functions

* `WHERE`
    * AND, OR, NOT
    * `<` `<=` `=` `=>` `>`

* `BETWEEN` - for *where*
* `IN` - checking set membership
* `NULL` values
* `IFNULL` operator
* String matches `%%`

<p>&nbsp;</p>

See the [MySQL *Functions* documentation](https://dev.mysql.com/doc/refman/8.0/en/functions.html)

:::
::::



<!DOCTYPE html>
<html lang="en"><head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="lecture-08_files/libs/clipboard/clipboard.min.js"></script>
<script src="lecture-08_files/libs/quarto-html/tabby.min.js"></script>
<script src="lecture-08_files/libs/quarto-html/popper.min.js"></script>
<script src="lecture-08_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="lecture-08_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lecture-08_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="lecture-08_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lecture-08_files/libs/quarto-contrib/reveal-header-1.0.0/add_header.js" defer="true"></script>
<link href="lecture-08_files/libs/quarto-contrib/reveal-header-1.0.0/add_header.css" rel="stylesheet">
<link href="lecture-08_files/libs/quarto-contrib/grid-htext-1.0.0/grid_htext.css" rel="stylesheet"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.6.40">

  <title>Relational Algebra 2</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="lecture-08_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="lecture-08_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="lecture-08_files/libs/revealjs/dist/theme/quarto-67f8f91f68d53fc8ccb8d34b88cf51f7.css">
  <link rel="stylesheet" href="assets/sketch-css.css">
  <link href="lecture-08_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="lecture-08_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="lecture-08_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="lecture-08_files/libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="lecture-08_files/libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="lecture-08_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
  
  <script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
  <script src="https://toolness.github.io/p5.js-widget/p5-widget.js"></script>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Relational Algebra 2</h1>
  <p class="subtitle">Lecture 8</p>

<div class="quarto-title-authors">
</div>

  <p class="date">Thursday - Feb 6, 2025</p>
</section>
<section class="slide level2">

<!-- # Set Operations -->
</section>
<section id="introduction-to-set-theory-and-relational-algebra" class="slide level2">
<h2>Introduction to Set Theory and Relational Algebra</h2>
<p>Set theory is a fundamental concept in relational algebra, providing the basis for operations that manipulate relations. These operations enable combining and filtering data effectively in relational databases.</p>
<div class="columns">
<div class="column" style="width:47%;">
<ul>
<li>Set theory deals with the mathematical concept of sets, collections of distinct elements.</li>
<li>Relational algebra applies set theory to relations (tables) in databases.</li>
<li>Common operations include union, intersection, difference, and Cartesian product.</li>
<li>These operations allow manipulation of data across multiple relations.</li>
<li>Set operations are performed on relations that have the same schema.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"><img data-src=".//assets/codd_acm_article.png"></a></p>
</div></div>
<p><em>Set theory is essential for understanding how relational algebra manipulates and combines relations.</em></p>
<!-- -->
</section>
<section id="intersection-operation-in-relational-algebra" class="slide level2 scrollable">
<h2>Intersection Operation in Relational Algebra</h2>
<p>The intersection operation retrieves rows that are common to two relations. It is used to find data that appears in both relations, making it useful when comparing datasets or finding shared entries between relations.</p>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>∩ - Intersection</strong></p>
<ul>
<li>Intersection finds common tuples between two relations.</li>
<li>The result includes only those tuples that appear in both relations.</li>
<li>Denoted as Relation1 ∩ Relation2</li>
<li>It’s a binary operation, meaning it operates on two relations.</li>
<li>Both relations must be <em>union-compatible</em>, meaning they have the same set of attributes and data types.</li>
<li>Intersection is often used in conjunction with other set-based operations like union and difference.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<div id="b1f7efb9" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-08_files/figure-revealjs/cell-4-output-1.png" width="299" height="229"></p>
</figure>
</div>
</div>
</div>
<p><strong>Examples</strong></p>
<p>Given two relations <em>Students(ID,Name,Major)</em> and <em>Registered(ID,Name,Major)</em>,</p>
<p>The following are valid examples of the <span class="math inline">\(\cap\)</span> in unicode:</p>
<ol type="1">
<li><p>Students ∩ Registered</p></li>
<li><p>Courses ∩ OfferedCourses</p></li>
<li><p>Employees ∩ Managers</p></li>
</ol>
</div></div>
<!-- -->
<p><em>Intersection is useful for finding commonality between two sets of data in relational databases.</em></p>
</section>
<section id="properties-of-the-intersection-operator" class="slide level2">
<h2>Properties of the Intersection Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \cap R_2 = { t \mid t \in R_1 \text{ and } t \in R_2 }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t\)</span> is a row (tuple),</li>
<li><span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are relations (tables) with the same attributes,</li>
<li>The intersection operation returns a new relation containing only the rows that are present in both <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>,</li>
<li>The result consists of distinct rows that satisfy the condition of being in both relations.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Idempotent</strong> – Applying the intersection of a relation with itself doesn’t change the result:</li>
</ul>
<p><span class="math display">\[
R \cap R = R
\]</span></p>
<ul>
<li><strong>Commutative</strong> – The order of relations in an intersection operation doesn’t matter:</li>
</ul>
<p><span class="math display">\[
R_1 \cap R_2 = R_2 \cap R_1
\]</span></p>
<ul>
<li><strong>Associative</strong> – The grouping of intersection operations doesn’t affect the result:</li>
</ul>
<p><span class="math display">\[
(R_1 \cap R_2) \cap R_3 = R_1 \cap (R_2 \cap R_3)
\]</span></p>
<ul>
<li><strong>Intersection with an empty set</strong> – The intersection of a relation with an empty set is the empty set:</li>
</ul>
<p><span class="math display">\[
R \cap \emptyset = \emptyset
\]</span></p>
<ul>
<li><strong>Intersection distributes over union</strong> – The intersection of two relations distributes over their union:</li>
</ul>
<p><span class="math display">\[
R_1 \cap (R_2 \cup R_3) = (R_1 \cap R_2) \cup (R_1 \cap R_3)
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Idempotent</strong>: Combining a relation with itself using intersection does not remove any rows, so the result remains the same.</li>
<li><strong>Commutative</strong>: The order of the relations in the intersection operation does not affect the result.</li>
<li><strong>Associative</strong>: You can group intersection operations in any way, and the result will be the same.</li>
<li><strong>Intersection with an empty set</strong>: Intersecting with an empty relation results in an empty set because no rows can be in both the original relation and an empty set.</li>
<li><strong>Distributed</strong>: Intersection distributes over union, meaning you can break down or combine intersections in a structured way over unions.</li>
</ul>
</section>
<section id="intersection-----example-1" class="slide level2">
<h2>Intersection - ∩ - Example 1</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="6f6ec175" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="37d3942d" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses1</em> <span class="math inline">\(\cap\)</span> <em>Courses2</em> returns:</p>
<div id="d3715940" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="difference-in-relational-algebra" class="slide level2">
<h2>Difference in Relational Algebra</h2>
<p>Difference in relational algebra subtracts one relation from another, returning the rows that are present in the first relation but not the second.</p>
<div class="columns">
<div class="column" style="width:47%;">
<ul>
<li>The difference operation returns tuples that are in one relation but not in the other.</li>
<li>It is often used to filter out unwanted data from a larger dataset.</li>
<li>The relations must have the same schema for the difference operation to be valid.</li>
<li>This operation can help isolate unique data points in a relation.</li>
<li>The result is a relation that includes only the data exclusive to the first set.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<div id="42e85fcf" class="cell" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-08_files/figure-revealjs/cell-8-output-1.png" width="299" height="229"></p>
</figure>
</div>
</div>
</div>
</div></div>
<!-- -->
<p><em>Difference is a powerful tool for excluding data from one relation that is present in another.</em></p>
</section>
<section id="properties-of-the-difference-operator" class="slide level2">
<h2>Properties of the Difference Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 - R_2 = { t \mid t \in R_1 \text{ and } t \notin R_2 }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t\)</span> is a row (tuple),</li>
<li><span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are relations (tables) with the same attributes,</li>
<li>The difference operation returns a new relation containing only the rows that are in <span class="math inline">\(R_1\)</span> but not in <span class="math inline">\(R_2\)</span>,</li>
<li>The result consists of distinct rows that exist in <span class="math inline">\(R_1\)</span> and are absent from <span class="math inline">\(R_2\)</span>.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Non-commutative</strong> – The order of relations in the difference operation matters:</li>
</ul>
<p><span class="math display">\[
R_1 - R_2 \neq R_2 - R_1
\]</span></p>
<ul>
<li><strong>Not associative</strong> – Grouping difference operations affects the result:</li>
</ul>
<p><span class="math display">\[
(R_1 - R_2) - R_3 \neq R_1 - (R_2 - R_3)
\]</span></p>
<ul>
<li><strong>Difference with an empty set</strong> – The difference between a relation and an empty set is the relation itself:</li>
</ul>
<p><span class="math display">\[
R_1 - \emptyset = R_1
\]</span></p>
<ul>
<li><strong>Difference with itself</strong> – The difference between a relation and itself is the empty set:</li>
</ul>
<p><span class="math display">\[
R_1 - R_1 = \emptyset
\]</span></p>
<ul>
<li><strong>Distributive over intersection</strong> – The difference operation distributes over intersection:</li>
</ul>
<p><span class="math display">\[
R_1 - (R_2 \cap R_3) = (R_1 - R_2) \cap (R_1 - R_3)
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-1" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Non-commutative</strong>: The order in which the relations are used in the difference matters because the result will include rows from <span class="math inline">\(R_1\)</span> that are not in <span class="math inline">\(R_2\)</span>, but not vice versa.</li>
<li><strong>Not associative</strong>: The grouping of relations in a difference operation affects the outcome since subtracting another relation later changes the rows that remain.</li>
<li><strong>Difference with an empty set</strong>: Subtracting an empty set from a relation has no effect since there are no rows to remove.</li>
<li><strong>Difference with itself</strong>: Subtracting a relation from itself results in an empty set, as no rows are left.</li>
<li><strong>Distributive over intersection</strong>: Difference distributes over intersection, allowing you to apply the difference to both parts of the intersection separately and then take their intersection.</li>
</ul>
</section>
<section id="difference-------example-1" class="slide level2">
<h2>Difference - <span class="math inline">\(-\)</span> - Example 1</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="1d7f453e" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="702ab386" class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses1</em> <span class="math inline">\(-\)</span> <em>Courses2</em> returns:</p>
<div id="a6d9327f" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="difference-------example-2" class="slide level2">
<h2>Difference - <span class="math inline">\(-\)</span> - Example 2</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="a4beddb1" class="cell" data-execution_count="11">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="f4c3ec66" class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses2</em> <span class="math inline">\(-\)</span> <em>Courses1</em> returns:</p>
<div id="83c10e4d" class="cell" data-execution_count="13">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="combining-relations-using-set-operations" class="slide level2">
<h2>Combining Relations Using Set Operations</h2>
<p>Set operations allow the combination of multiple relations in a variety of ways, depending on the desired outcome of the query.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Relational algebra supports various set operations like union, intersection, and difference.</li>
<li>These operations allow filtering and merging data across relations.</li>
<li>Set operations are only valid when the schemas of the involved relations match.</li>
<li>Use cases include combining multiple tables, finding common data, or filtering out specific records.</li>
<li>Understanding these operations is key to effective data manipulation in relational databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Set operations provide flexible tools for combining and comparing datasets in relational databases.</em></p>
</section>
<section id="set-operation-requirements-and-considerations" class="slide level2">
<h2>Set Operation Requirements and Considerations</h2>
<p>When performing set operations, it’s essential to ensure that both relations have compatible schemas and understand how each operation behaves.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Set operations can only be performed on relations with identical schemas.</li>
<li>The number of attributes and their types must match for the operation to succeed.</li>
<li>Set operations can return large results, depending on the size of the input relations.</li>
<li>Performance considerations include the size of relations and efficiency of the operation.</li>
<li>Proper indexing can improve the speed of set operations in large databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Understanding the requirements of set operations ensures successful and efficient data manipulation.</em></p>
</section>
<section id="examples-of-set-operations-in-relational-queries" class="slide level2">
<h2>Examples of Set Operations in Relational Queries</h2>
<p>Relational algebra operations like union, intersection, and difference can be directly applied in database queries to filter and combine data.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Example: Union of two employee tables to combine employee records from two departments.</li>
<li>Example: Intersection of student and graduate tables to find students who have graduated.</li>
<li>Example: Difference between a product catalog and inventory to find out-of-stock items.</li>
<li>Cartesian product used to combine customer and order tables for further analysis.</li>
<li>Practical queries often combine set operations with other relational algebra operations.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Set operations are applied in real-world scenarios to efficiently manipulate and query data.</em></p>
</section>
<section id="set-operations-in-real-world-databases" class="slide level2">
<h2>Set Operations in Real-World Databases</h2>
<p>Set operations play a vital role in real-world databases, helping manage and analyze large datasets effectively.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Used to merge large datasets across departments or organizations.</li>
<li>Helpful in financial reporting, where records from different periods or regions are combined.</li>
<li>Set operations can aid in data cleaning by removing duplicates or irrelevant records.</li>
<li>They are fundamental in multi-relational databases where data is distributed across tables.</li>
<li>Often used in cloud environments for large-scale data analysis and processing.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>In practice, set operations streamline data integration and analysis across various industries.</em></p>
</section>
<section id="summary-of-set-operations-in-relational-algebra" class="slide level2">
<h2>Summary of Set Operations in Relational Algebra</h2>
<p>Set operations, including union, intersection, difference, and Cartesian product, are key tools in relational algebra for manipulating and combining relations. They enable powerful queries that form the basis of relational database functionality.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Set theory provides the foundation for combining and filtering relations.</li>
<li>Intersection finds common records, while difference filters out data from one relation.</li>
<li>Cartesian product creates all possible combinations of tuples from two relations.</li>
<li>Union merges two relations, removing duplicates.</li>
<li>These operations are essential for querying and managing relational databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Mastery of set operations in relational algebra allows for complex and efficient database queries.</em></p>
</section>
<section id="housekeeping" class="slide level2">
<h2>Housekeeping</h2>
<div class="columns">
<div class="column" style="width:9%;">

</div><div class="column" style="width:45%;">
<h3 id="discussion-items">Discussion items</h3>
<ul>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/quizzes/211171">Practice Quiz 2 </a> - due Feb.&nbsp;4, TUE</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1072335">Homework 2 - ER Modeling </a> - due Feb.&nbsp;4, TUE</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1075914">Discussion 2 - Relational Algebra</a> - due Feb.&nbsp;9, SUN</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1075768">Del.4 - Video Pitch</a> - due Feb.&nbsp;9, SUN</p></li>
</ul>
</div><div class="column" style="width:40%;">
<h3 id="lecture-topics">Lecture topics</h3>
<ul>
<li><p><a href="#/deliverable-4-notes">Deliverable 4 Notes</a></p></li>
<li><p><a href="#/set-operations">Set Operations</a></p></li>
<li><p><a href="#/join-operations">Join Operations</a></p></li>
<li><p><a href="#/rename-and-division">Renaming and Division</a></p></li>
</ul>
</div></div>
<div style="margin-top:25px">
<p>&nbsp;</p>
</div>

    <style></style>
    <div class="upcoming-calendar">
<table class="caption-top" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: center;" data-quarto-table-cell-role="th">Module</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Week</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Date</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Day</th>
<th data-quarto-table-cell-role="th">Notes and Lectures</th>
<th data-quarto-table-cell-role="th">Activities and due dates</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/4</td>
<td style="text-align: center;">Tue</td>
<td>L7:Relational Algebra 1</td>
<td>PQ2:Relational Algebra; HW2:Entity Relation Models</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/6</td>
<td style="text-align: center;">Thu</td>
<td>L8:Relational Algebra 2</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/9</td>
<td style="text-align: center;">Sun</td>
<td></td>
<td>Prj4:Video Pitch; Dis2:Relational Alg.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/10</td>
<td style="text-align: center;">Mon</td>
<td>Last day for progress reports</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/11</td>
<td style="text-align: center;">Tue</td>
<td>L9:Analysis and Normal Forms 1</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/12</td>
<td style="text-align: center;">Wed</td>
<td>Career Fair (10am-3pm)</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/13</td>
<td style="text-align: center;">Thu</td>
<td>NO CLASS - Interview Day (10am-3pm)</td>
<td>Q2:Relational Algebra</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/16</td>
<td style="text-align: center;">Sun</td>
<td></td>
<td>HW3:Modeling Your World</td>
</tr>
</tbody>
</table>
</div>
<!-- lecture-block-begin -->
</section>
<section>
<section id="deliverable-4-notes" class="title-slide slide level1 center">
<h1>Deliverable 4 Notes</h1>
<!-- # Deliverable 4 - Video Pitch SP2025 -->
</section>
<section id="deliverable-4---video-pitch" class="slide level2">
<h2>Deliverable 4 - <a href="https://vcu.mediaspace.kaltura.com/media/CMSC408-SP2025-Video-Pitch-Example/1_3pync139">Video Pitch</a></h2>
<div class="columns">
<div class="column" style="width:50%;">
<h3 id="creating-the-video-pitch">Creating the Video Pitch</h3>
<ul>
<li><p><strong>As a group, pick the topic</strong></p></li>
<li><p><strong>Create a video using Zoom (or whatever).</strong></p>
<ul>
<li>Use your VCU email to log into Zoom,</li>
<li>Record “to the cloud”</li>
</ul></li>
<li><p><strong>Look for the video in Kaltura</strong></p>
<ul>
<li><a href="https://vcu.mediaspace.kaltura.com/my-media" class="uri">https://vcu.mediaspace.kaltura.com/my-media</a></li>
<li><em>Launch Editor</em> and trim as necessary</li>
</ul></li>
<li><p><strong>Change permissions</strong></p>
<ul>
<li><em>Edit</em> video and <em>Publish</em> to to <em>anyone with link</em></li>
<li><em>Save</em> changes</li>
<li><em>Share</em> tab, get <em>Embed</em> <code>iframe</code> codes</li>
</ul></li>
<li><p><strong>Add to Quarto</strong></p>
<ul>
<li><em>Paste</em> into <em>reports.qmd</em></li>
<li><em>Render</em> and verify that it works.</li>
</ul></li>
</ul>
</div><div class="column" style="width:50%;">
<h3 id="creating-the-shared-repository">Creating the SHARED repository</h3>
<ul>
<li><strong>ONE PERSON on the team should “go first”</strong>
<ul>
<li><a href="https://classroom.github.com/a/8kcaaebR" class="uri">https://classroom.github.com/a/8kcaaebR</a></li>
<li>You’ll be asked to name your team</li>
<li>You’re github username will be added to the team</li>
</ul></li>
<li><strong>OTHERS ON THE TEAM</strong>
<ul>
<li><a href="https://classroom.github.com/a/8kcaaebR" class="uri">https://classroom.github.com/a/8kcaaebR</a></li>
<li>Select your team from the list to <em>join</em> it.</li>
<li>You’re github username will be added to the team.</li>
</ul></li>
<li><strong>Review the Scaffold and make your report</strong>
<ul>
<li>Review <em>report.qmd</em></li>
<li>Render to create <em>report.html</em></li>
</ul></li>
<li><strong>Finally …</strong>
<ul>
<li>Each team mamber uploads the repo to gradescope INDIVIDUALLY,</li>
<li>One person uploaded the HTML document to Canvas FOR THE TEAM.</li>
</ul></li>
</ul>
</div></div>
</section></section>
<section>
<section id="set-operations" class="title-slide slide level1 center">
<h1>Set Operations</h1>
<!-- # Set Operations -->
</section>
<section id="introduction-to-set-theory-and-relational-algebra-1" class="slide level2">
<h2>Introduction to Set Theory and Relational Algebra</h2>
<p>Set theory is a fundamental concept in relational algebra, providing the basis for operations that manipulate relations. These operations enable combining and filtering data effectively in relational databases.</p>
<div class="columns">
<div class="column" style="width:47%;">
<ul>
<li>Set theory deals with the mathematical concept of sets, collections of distinct elements.</li>
<li>Relational algebra applies set theory to relations (tables) in databases.</li>
<li>Common operations include union, intersection, difference, and Cartesian product.</li>
<li>These operations allow manipulation of data across multiple relations.</li>
<li>Set operations are performed on relations that have the same schema.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf"><img data-src=".//assets/codd_acm_article.png"></a></p>
</div></div>
<p><em>Set theory is essential for understanding how relational algebra manipulates and combines relations.</em></p>
<!-- -->
</section>
<section id="intersection-operation-in-relational-algebra-1" class="slide level2 scrollable">
<h2>Intersection Operation in Relational Algebra</h2>
<p>The intersection operation retrieves rows that are common to two relations. It is used to find data that appears in both relations, making it useful when comparing datasets or finding shared entries between relations.</p>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>∩ - Intersection</strong></p>
<ul>
<li>Intersection finds common tuples between two relations.</li>
<li>The result includes only those tuples that appear in both relations.</li>
<li>Denoted as Relation1 ∩ Relation2</li>
<li>It’s a binary operation, meaning it operates on two relations.</li>
<li>Both relations must be <em>union-compatible</em>, meaning they have the same set of attributes and data types.</li>
<li>Intersection is often used in conjunction with other set-based operations like union and difference.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<div id="f81fad3b" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-08_files/figure-revealjs/cell-17-output-1.png" width="299" height="229"></p>
</figure>
</div>
</div>
</div>
<p><strong>Examples</strong></p>
<p>Given two relations <em>Students(ID,Name,Major)</em> and <em>Registered(ID,Name,Major)</em>,</p>
<p>The following are valid examples of the <span class="math inline">\(\cap\)</span> in unicode:</p>
<ol type="1">
<li><p>Students ∩ Registered</p></li>
<li><p>Courses ∩ OfferedCourses</p></li>
<li><p>Employees ∩ Managers</p></li>
</ol>
</div></div>
<!-- -->
<p><em>Intersection is useful for finding commonality between two sets of data in relational databases.</em></p>
</section>
<section id="properties-of-the-intersection-operator-1" class="slide level2">
<h2>Properties of the Intersection Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \cap R_2 = { t \mid t \in R_1 \text{ and } t \in R_2 }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t\)</span> is a row (tuple),</li>
<li><span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are relations (tables) with the same attributes,</li>
<li>The intersection operation returns a new relation containing only the rows that are present in both <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>,</li>
<li>The result consists of distinct rows that satisfy the condition of being in both relations.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Idempotent</strong> – Applying the intersection of a relation with itself doesn’t change the result:</li>
</ul>
<p><span class="math display">\[
R \cap R = R
\]</span></p>
<ul>
<li><strong>Commutative</strong> – The order of relations in an intersection operation doesn’t matter:</li>
</ul>
<p><span class="math display">\[
R_1 \cap R_2 = R_2 \cap R_1
\]</span></p>
<ul>
<li><strong>Associative</strong> – The grouping of intersection operations doesn’t affect the result:</li>
</ul>
<p><span class="math display">\[
(R_1 \cap R_2) \cap R_3 = R_1 \cap (R_2 \cap R_3)
\]</span></p>
<ul>
<li><strong>Intersection with an empty set</strong> – The intersection of a relation with an empty set is the empty set:</li>
</ul>
<p><span class="math display">\[
R \cap \emptyset = \emptyset
\]</span></p>
<ul>
<li><strong>Intersection distributes over union</strong> – The intersection of two relations distributes over their union:</li>
</ul>
<p><span class="math display">\[
R_1 \cap (R_2 \cup R_3) = (R_1 \cap R_2) \cup (R_1 \cap R_3)
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-2" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Idempotent</strong>: Combining a relation with itself using intersection does not remove any rows, so the result remains the same.</li>
<li><strong>Commutative</strong>: The order of the relations in the intersection operation does not affect the result.</li>
<li><strong>Associative</strong>: You can group intersection operations in any way, and the result will be the same.</li>
<li><strong>Intersection with an empty set</strong>: Intersecting with an empty relation results in an empty set because no rows can be in both the original relation and an empty set.</li>
<li><strong>Distributed</strong>: Intersection distributes over union, meaning you can break down or combine intersections in a structured way over unions.</li>
</ul>
</section>
<section id="intersection-----example-1-1" class="slide level2">
<h2>Intersection - ∩ - Example 1</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="1144be3f" class="cell" data-execution_count="17">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="a2c06d73" class="cell" data-execution_count="18">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses1</em> <span class="math inline">\(\cap\)</span> <em>Courses2</em> returns:</p>
<div id="ae8e0697" class="cell" data-execution_count="19">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="difference-in-relational-algebra-1" class="slide level2">
<h2>Difference in Relational Algebra</h2>
<p>Difference in relational algebra subtracts one relation from another, returning the rows that are present in the first relation but not the second.</p>
<div class="columns">
<div class="column" style="width:47%;">
<ul>
<li>The difference operation returns tuples that are in one relation but not in the other.</li>
<li>It is often used to filter out unwanted data from a larger dataset.</li>
<li>The relations must have the same schema for the difference operation to be valid.</li>
<li>This operation can help isolate unique data points in a relation.</li>
<li>The result is a relation that includes only the data exclusive to the first set.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<div id="ff2b821f" class="cell" data-execution_count="20">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lecture-08_files/figure-revealjs/cell-21-output-1.png" width="299" height="229"></p>
</figure>
</div>
</div>
</div>
</div></div>
<!-- -->
<p><em>Difference is a powerful tool for excluding data from one relation that is present in another.</em></p>
</section>
<section id="properties-of-the-difference-operator-1" class="slide level2">
<h2>Properties of the Difference Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 - R_2 = { t \mid t \in R_1 \text{ and } t \notin R_2 }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t\)</span> is a row (tuple),</li>
<li><span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are relations (tables) with the same attributes,</li>
<li>The difference operation returns a new relation containing only the rows that are in <span class="math inline">\(R_1\)</span> but not in <span class="math inline">\(R_2\)</span>,</li>
<li>The result consists of distinct rows that exist in <span class="math inline">\(R_1\)</span> and are absent from <span class="math inline">\(R_2\)</span>.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Non-commutative</strong> – The order of relations in the difference operation matters:</li>
</ul>
<p><span class="math display">\[
R_1 - R_2 \neq R_2 - R_1
\]</span></p>
<ul>
<li><strong>Not associative</strong> – Grouping difference operations affects the result:</li>
</ul>
<p><span class="math display">\[
(R_1 - R_2) - R_3 \neq R_1 - (R_2 - R_3)
\]</span></p>
<ul>
<li><strong>Difference with an empty set</strong> – The difference between a relation and an empty set is the relation itself:</li>
</ul>
<p><span class="math display">\[
R_1 - \emptyset = R_1
\]</span></p>
<ul>
<li><strong>Difference with itself</strong> – The difference between a relation and itself is the empty set:</li>
</ul>
<p><span class="math display">\[
R_1 - R_1 = \emptyset
\]</span></p>
<ul>
<li><strong>Distributive over intersection</strong> – The difference operation distributes over intersection:</li>
</ul>
<p><span class="math display">\[
R_1 - (R_2 \cap R_3) = (R_1 - R_2) \cap (R_1 - R_3)
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-3" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Non-commutative</strong>: The order in which the relations are used in the difference matters because the result will include rows from <span class="math inline">\(R_1\)</span> that are not in <span class="math inline">\(R_2\)</span>, but not vice versa.</li>
<li><strong>Not associative</strong>: The grouping of relations in a difference operation affects the outcome since subtracting another relation later changes the rows that remain.</li>
<li><strong>Difference with an empty set</strong>: Subtracting an empty set from a relation has no effect since there are no rows to remove.</li>
<li><strong>Difference with itself</strong>: Subtracting a relation from itself results in an empty set, as no rows are left.</li>
<li><strong>Distributive over intersection</strong>: Difference distributes over intersection, allowing you to apply the difference to both parts of the intersection separately and then take their intersection.</li>
</ul>
</section>
<section id="difference-------example-1-1" class="slide level2">
<h2>Difference - <span class="math inline">\(-\)</span> - Example 1</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="3610d2a7" class="cell" data-execution_count="21">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="ce59475e" class="cell" data-execution_count="22">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses1</em> <span class="math inline">\(-\)</span> <em>Courses2</em> returns:</p>
<div id="70c013e1" class="cell" data-execution_count="23">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="difference-------example-2-1" class="slide level2">
<h2>Difference - <span class="math inline">\(-\)</span> - Example 2</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Courses1( Course,Term)</em>:</p>
<div id="537de26d" class="cell" data-execution_count="24">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC301</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC408</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Courses2( Course,Term )</em>:</p>
<div id="7afa9e09" class="cell" data-execution_count="25">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
<tr class="even">
<td>CMSC408</td>
<td>Fall 2024</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Courses2</em> <span class="math inline">\(-\)</span> <em>Courses1</em> returns:</p>
<div id="5ee99967" class="cell" data-execution_count="26">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CMSC110</td>
<td>Fall 2024</td>
</tr>
<tr class="even">
<td>CMSC201</td>
<td>Fall 2024</td>
</tr>
<tr class="odd">
<td>CMSC475</td>
<td>Fall 2023</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div></div>
<!-- -->
</section>
<section id="combining-relations-using-set-operations-1" class="slide level2">
<h2>Combining Relations Using Set Operations</h2>
<p>Set operations allow the combination of multiple relations in a variety of ways, depending on the desired outcome of the query.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Relational algebra supports various set operations like union, intersection, and difference.</li>
<li>These operations allow filtering and merging data across relations.</li>
<li>Set operations are only valid when the schemas of the involved relations match.</li>
<li>Use cases include combining multiple tables, finding common data, or filtering out specific records.</li>
<li>Understanding these operations is key to effective data manipulation in relational databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Set operations provide flexible tools for combining and comparing datasets in relational databases.</em></p>
</section>
<section id="set-operation-requirements-and-considerations-1" class="slide level2">
<h2>Set Operation Requirements and Considerations</h2>
<p>When performing set operations, it’s essential to ensure that both relations have compatible schemas and understand how each operation behaves.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Set operations can only be performed on relations with identical schemas.</li>
<li>The number of attributes and their types must match for the operation to succeed.</li>
<li>Set operations can return large results, depending on the size of the input relations.</li>
<li>Performance considerations include the size of relations and efficiency of the operation.</li>
<li>Proper indexing can improve the speed of set operations in large databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Understanding the requirements of set operations ensures successful and efficient data manipulation.</em></p>
</section>
<section id="examples-of-set-operations-in-relational-queries-1" class="slide level2">
<h2>Examples of Set Operations in Relational Queries</h2>
<p>Relational algebra operations like union, intersection, and difference can be directly applied in database queries to filter and combine data.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Example: Union of two employee tables to combine employee records from two departments.</li>
<li>Example: Intersection of student and graduate tables to find students who have graduated.</li>
<li>Example: Difference between a product catalog and inventory to find out-of-stock items.</li>
<li>Cartesian product used to combine customer and order tables for further analysis.</li>
<li>Practical queries often combine set operations with other relational algebra operations.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Set operations are applied in real-world scenarios to efficiently manipulate and query data.</em></p>
</section>
<section id="set-operations-in-real-world-databases-1" class="slide level2">
<h2>Set Operations in Real-World Databases</h2>
<p>Set operations play a vital role in real-world databases, helping manage and analyze large datasets effectively.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Used to merge large datasets across departments or organizations.</li>
<li>Helpful in financial reporting, where records from different periods or regions are combined.</li>
<li>Set operations can aid in data cleaning by removing duplicates or irrelevant records.</li>
<li>They are fundamental in multi-relational databases where data is distributed across tables.</li>
<li>Often used in cloud environments for large-scale data analysis and processing.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>In practice, set operations streamline data integration and analysis across various industries.</em></p>
</section>
<section id="summary-of-set-operations-in-relational-algebra-1" class="slide level2">
<h2>Summary of Set Operations in Relational Algebra</h2>
<p>Set operations, including union, intersection, difference, and Cartesian product, are key tools in relational algebra for manipulating and combining relations. They enable powerful queries that form the basis of relational database functionality.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Set theory provides the foundation for combining and filtering relations.</li>
<li>Intersection finds common records, while difference filters out data from one relation.</li>
<li>Cartesian product creates all possible combinations of tuples from two relations.</li>
<li>Union merges two relations, removing duplicates.</li>
<li>These operations are essential for querying and managing relational databases.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Mastery of set operations in relational algebra allows for complex and efficient database queries.</em></p>
</section></section>
<section>
<section id="join-operations" class="title-slide slide level1 center">
<h1>Join Operations</h1>
<!-- # Join Operations -->
</section>
<section id="introduction-to-join-operations-in-relational-algebra" class="slide level2">
<h2>Introduction to Join Operations in Relational Algebra</h2>
<p>Join operations allow you to combine data from two or more relations based on a condition. Understanding these operations is key to querying relational databases effectively.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Joins combine related data from different relations.</li>
<li>A condition (join predicate) specifies how to match tuples from different relations.</li>
<li>Common types of joins include inner and outer joins.</li>
<li>Joins are fundamental to multi-relation queries.</li>
<li>Different types of joins solve different query requirements.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Joins are essential in connecting data from multiple tables in relational databases.</em></p>
</section>
<section id="inner-join-definition-and-use" class="slide level2">
<h2>Inner Join: Definition and Use</h2>
<p>Inner join is the most common type of join, which only returns matching tuples from both relations. It is frequently used in relational databases.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Inner join retrieves only the matching tuples from two relations.</li>
<li>Non-matching tuples are excluded from the result.</li>
<li>The join condition specifies how tuples are matched.</li>
<li>Useful when you need to combine data from two relations where all entries meet a condition.</li>
<li>Most common join operation in SQL and relational algebra.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Inner join is ideal when you only need rows where data exists in both relations.</em></p>
</section>
<section id="properties-of-the-inner-join-operator" class="slide level2">
<h2>Properties of the Inner Join Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \bowtie_{condition} R_2 = { t_1 , t_2 \mid t_1 \in R_1, t_2 \in R_2, \text{ and } condition(t_1, t_2) }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t_1\)</span> is a row (tuple) from relation <span class="math inline">\(R_1\)</span>,</li>
<li><span class="math inline">\(t_2\)</span> is a row (tuple) from relation <span class="math inline">\(R_2\)</span>,</li>
<li>The <strong>inner join</strong> combines rows from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> based on a specified <strong>join condition</strong>,</li>
<li>The result contains only those rows where the condition is true for both relations (i.e., rows in <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> that satisfy the join condition).</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Non-commutative</strong> – The order of relations matters in inner join (unless the join condition is symmetric):</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie_{condition} R_2 \neq R_2 \bowtie_{condition} R_1
\]</span> (Unless <span class="math inline">\(condition(t_1, t_2) = condition(t_2, t_1)\)</span>)</p>
<ul>
<li><strong>Associative</strong> – Grouping inner join operations doesn’t affect the result:</li>
</ul>
<p><span class="math display">\[
(R_1 \bowtie_{condition1} R_2) \bowtie_{condition2} R_3 = R_1 \bowtie_{condition1} (R_2 \bowtie_{condition2} R_3)
\]</span></p>
<ul>
<li><strong>Inner join with an empty set</strong> – The inner join with an empty relation results in an empty set:</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie_{condition} \emptyset = \emptyset
\]</span></p>
<ul>
<li><strong>Distributive over selection</strong> – Inner join distributes over selection:</li>
</ul>
<p><span class="math display">\[
\sigma_{condition}(R_1 \bowtie R_2) = (\sigma_{condition}(R_1)) \bowtie R_2
\]</span> (if the selection condition applies to <span class="math inline">\(R_1\)</span> only)</p>
<ul>
<li><strong>Size of result</strong> – The number of rows in the result depends on how many rows from <span class="math inline">\(R_1\)</span> match rows in <span class="math inline">\(R_2\)</span> under the join condition.</li>
</ul>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-4" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Non-commutative</strong>: The order of the relations in the inner join may affect the result unless the join condition is symmetric (e.g., <span class="math inline">\(A = B\)</span> is the same as <span class="math inline">\(B = A\)</span>).</li>
<li><strong>Associative</strong>: Grouping inner joins differently doesn’t change the result as long as the conditions are applied consistently.</li>
<li><strong>Inner join with an empty set</strong>: If either relation is empty, the result is an empty set because no rows can satisfy the join condition.</li>
<li><strong>Distributive over selection</strong>: You can first apply a selection condition to one of the relations and then join it with the other relation without affecting the outcome, assuming the selection condition applies to that relation only.</li>
<li><strong>Size of result</strong>: The size of the result is determined by the number of matching rows in <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> that satisfy the join condition.</li>
</ul>
<p>This structure mirrors the other relational algebra operations and highlights the key properties of the inner join.</p>
</section>
<section id="inner-join-----example-1" class="slide level2">
<h2>Inner Join - ⋈ - Example 1</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Students(VID,Name,Major)</em>:</p>
<div id="5b630e3e" class="cell" data-execution_count="28">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">VID</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Major</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>V10101</td>
<td>Alice</td>
<td>CS</td>
</tr>
<tr class="even">
<td>V10102</td>
<td>Bob</td>
<td>Math</td>
</tr>
<tr class="odd">
<td>V10103</td>
<td>Carol</td>
<td>CS</td>
</tr>
<tr class="even">
<td>V10104</td>
<td>Dave</td>
<td>Physics</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Enrollments(VID,Course,Term,Enrl)</em>:</p>
<div id="4fed0650" class="cell" data-execution_count="29">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">VID</th>
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
<th data-quarto-table-cell-role="th">Enrl</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>V10101</td>
<td>CMSC460</td>
<td>Spring 2024</td>
<td>100</td>
</tr>
<tr class="even">
<td>V10103</td>
<td>CMSC455</td>
<td>Spring 2024</td>
<td>150</td>
</tr>
<tr class="odd">
<td>V10105</td>
<td>CMSC420</td>
<td>Spring 2024</td>
<td>120</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Find all the data for students enrolled in classes</strong></p>
<p><em>Students</em> ⋈ (<em>VID</em>) <em>Enrollments</em>;</p>
<div id="5f712679" class="cell" data-execution_count="30">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">VID</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Major</th>
<th data-quarto-table-cell-role="th">Course</th>
<th data-quarto-table-cell-role="th">Term</th>
<th data-quarto-table-cell-role="th">Enrl</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>V10101</td>
<td>Alice</td>
<td>CS</td>
<td>CMSC460</td>
<td>Spring 2024</td>
<td>100</td>
</tr>
<tr class="even">
<td>V10103</td>
<td>Carol</td>
<td>CS</td>
<td>CMSC455</td>
<td>Spring 2024</td>
<td>150</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<ul>
<li><p>This list does not include students who don’t have enrollments, nor enrollments with students not found in the relation.</p></li>
<li><p>What is the cardinality and participation?</p></li>
</ul>
</div></div>
<!-- -->
</section>
<section id="inner-join-----example-2" class="slide level2">
<h2>Inner Join - ⋈ - Example 2</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Menu(DishID, Dish, Price)</em>:</p>
<div id="04d4d7d0" class="cell" data-execution_count="32">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D001</td>
<td>Samosa</td>
<td>2.5</td>
</tr>
<tr class="even">
<td>D002</td>
<td>Butter Chicken</td>
<td>10.0</td>
</tr>
<tr class="odd">
<td>D003</td>
<td>Naan</td>
<td>1.5</td>
</tr>
<tr class="even">
<td>D004</td>
<td>Paneer Tikka</td>
<td>8.0</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Orders(OrderID, DishID, Quantity)</em>:</p>
<div id="3f1e3776" class="cell" data-execution_count="33">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>O1001</td>
<td>D001</td>
<td>2</td>
</tr>
<tr class="even">
<td>O1002</td>
<td>D003</td>
<td>3</td>
</tr>
<tr class="odd">
<td>O1003</td>
<td>D005</td>
<td>1</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Menu</em> ⋈ (<em>DishID</em>) <em>Orders</em> returns:</p>
<div id="87de7e5b" class="cell" data-execution_count="34">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D001</td>
<td>Samosa</td>
<td>2.5</td>
<td>O1001</td>
<td>2</td>
</tr>
<tr class="even">
<td>D003</td>
<td>Naan</td>
<td>1.5</td>
<td>O1002</td>
<td>3</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This example demonstrates how an inner join will return only the dishes from the <code>orders</code> that exist in the <code>menu</code>, leaving out any ordered dishes that are not on the menu (like <code>DishID: D005</code>).</p>
</div></div>
<!-- -->
</section>
<section id="outer-join-introduction-and-types" class="slide level2">
<h2>Outer Join: Introduction and Types</h2>
<p>Outer join returns all tuples from one or both relations, filling in missing values with NULLs. It allows for more inclusive queries.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Outer join returns matching and non-matching tuples.</li>
<li>NULL values are used for missing data.</li>
<li>There are three types: left, right, and full outer join.</li>
<li>Left outer join returns all tuples from the left relation and matches from the right.</li>
<li>Right outer join does the reverse: all from the right relation and matches from the left.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Outer joins are useful when you need to retain non-matching data from one or both relations.</em></p>
</section>
<section id="properties-of-the-outer-join-operator" class="slide level2">
<h2>Properties of the Outer Join Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
\begin{aligned}
R_1 \text{⟕}_{condition} R_2 = &amp;{ t_1 , t_2 \mid (t_1 \in R_1 \text{ and } t_2 \in R_2 \text{ and } condition(t_1, t_2)) } \
&amp;\cup { t_1 \mid t_1 \in R_1 \text{ and no match in } R_2 } \
&amp;\cup { t_2 \mid t_2 \in R_2 \text{ and no match in } R_1 }
\end{aligned}
\]</span></p>
<ul>
<li>where <span class="math inline">\(t_1\)</span> is a row (tuple) from relation <span class="math inline">\(R_1\)</span>,</li>
<li><span class="math inline">\(t_2\)</span> is a row (tuple) from relation <span class="math inline">\(R_2\)</span>,</li>
<li>The <strong>outer join</strong> combines rows from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> based on a specified <strong>join condition</strong>,</li>
<li>Unlike the inner join, the result includes all matching rows from both relations as well as non-matching rows, which are padded with <code>NULL</code> values where no match is found.</li>
</ul>
<p><strong>Types of outer join:</strong></p>
<ul>
<li><strong>Left outer join</strong>: Keeps all rows from <span class="math inline">\(R_1\)</span> and matches from <span class="math inline">\(R_2\)</span>.</li>
<li><strong>Right outer join</strong>: Keeps all rows from <span class="math inline">\(R_2\)</span> and matches from <span class="math inline">\(R_1\)</span>.</li>
<li><strong>Full outer join</strong>: Keeps all rows from both <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, including unmatched rows from both sides.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Non-commutative</strong> – The order of relations matters for left and right outer joins:</li>
</ul>
<p><span class="math display">\[
R_1 \text{⟕}_{condition} R_2 \neq R_2 \text{⟕}_{condition} R_1
\]</span> (unless using a <strong>full outer join</strong>)</p>
<ul>
<li><strong>Associative</strong> – Grouping outer joins can depend on the type of join but generally holds true for full outer joins:</li>
</ul>
<p><span class="math display">\[
(R_1 \text{⟕}_{condition1} R_2) \text{⟕}_{condition2} R_3 = R_1 \text{⟕}_{condition1} (R_2 \text{⟕}_{condition2} R_3)
\]</span> (applies to full outer joins)</p>
<ul>
<li><p><strong>Outer join with an empty set</strong> – The outer join with an empty relation depends on the type of outer join:</p>
<ul>
<li><strong>Left outer join</strong>: Returns all rows from <span class="math inline">\(R_1\)</span> with <code>NULL</code> for <span class="math inline">\(R_2\)</span>:</li>
</ul>
<p><span class="math display">\[
R_1 \text{⟕} \emptyset = R_1
\]</span></p>
<ul>
<li><strong>Right outer join</strong>: Returns all rows from <span class="math inline">\(R_2\)</span> with <code>NULL</code> for <span class="math inline">\(R_1\)</span>:</li>
</ul>
<p><span class="math display">\[
\emptyset  \text{⟕}  R_2 = R_2
\]</span></p>
<ul>
<li><strong>Full outer join</strong>: Results in both relations with unmatched rows being padded with <code>NULL</code>:</li>
</ul>
<p><span class="math display">\[
R_1  \text{⟕}  \emptyset = R_1 \quad \text{and} \quad \emptyset  \text{⟕}  R_2 = R_2
\]</span></p></li>
<li><p><strong>Distributive over selection</strong> – Outer join is not generally distributive over selection, as selection might remove rows that would otherwise be included with <code>NULL</code> values.</p></li>
</ul>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-5" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Non-commutative</strong>: The order of relations in left and right outer joins affects the result, but for full outer joins, the order does not matter.</li>
<li><strong>Associative</strong>: Full outer joins are associative, meaning you can group them in different ways and still get the same result.</li>
<li><strong>Outer join with an empty set</strong>: In left and right outer joins, the non-empty relation is returned with <code>NULL</code> values in place of the missing relation. For full outer joins, both relations contribute to the result, filling unmatched rows with <code>NULL</code>.</li>
<li><strong>Distributive over selection</strong>: Unlike the inner join, selection does not distribute cleanly over outer joins because rows with <code>NULL</code> values might be incorrectly excluded if the selection is applied beforehand.</li>
</ul>
</section>
<section id="left-outer-join-----example" class="slide level2">
<h2>Left Outer Join - ⟕ - Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Menu(DishID, Dish, Price)</em>:</p>
<div id="3a23ec39" class="cell" data-execution_count="36">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Spring Roll</td>
<td>5.0</td>
</tr>
<tr class="even">
<td>A002</td>
<td>Pad Thai</td>
<td>12.0</td>
</tr>
<tr class="odd">
<td>A003</td>
<td>Sushi</td>
<td>10.0</td>
</tr>
<tr class="even">
<td>A004</td>
<td>Ramen</td>
<td>8.0</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Orders(OrderID, DishID, Quantity)</em>:</p>
<div id="79ebdf6b" class="cell" data-execution_count="37">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>O2001</td>
<td>A001</td>
<td>1</td>
</tr>
<tr class="even">
<td>O2002</td>
<td>A003</td>
<td>2</td>
</tr>
<tr class="odd">
<td>O2003</td>
<td>A005</td>
<td>1</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Menu</em> ⟕ <em>Orders</em> on <em>DishID</em> returns:</p>
<div id="194fa40d" class="cell" data-execution_count="38">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Spring Roll</td>
<td>5.0</td>
<td>O2001</td>
<td>1.0</td>
</tr>
<tr class="even">
<td>A002</td>
<td>Pad Thai</td>
<td>12.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td>A003</td>
<td>Sushi</td>
<td>10.0</td>
<td>O2002</td>
<td>2.0</td>
</tr>
<tr class="even">
<td>A004</td>
<td>Ramen</td>
<td>8.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This example shows how a left outer join includes <strong>all rows from the left table</strong> (<code>Menu</code>), and the matching rows from the right table (<code>Orders</code>). If there is no match, <code>NULL</code> (or <code>NaN</code> in pandas) values are returned for the columns from the right table. Here, the <code>DishID: A005</code> from the <code>Orders</code> table does not exist in the <code>Menu</code>, so it is not included in the result, but all menu items are shown, regardless of whether they are ordered.</p>
</div></div>
<!-- -->
</section>
<section id="right-outer-join-----example" class="slide level2">
<h2>Right Outer Join - ⟖ - Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Menu(DishID, Dish, Price)</em>:</p>
<div id="78ac750c" class="cell" data-execution_count="40">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Spring Roll</td>
<td>5.0</td>
</tr>
<tr class="even">
<td>A002</td>
<td>Pad Thai</td>
<td>12.0</td>
</tr>
<tr class="odd">
<td>A003</td>
<td>Sushi</td>
<td>10.0</td>
</tr>
<tr class="even">
<td>A004</td>
<td>Ramen</td>
<td>8.0</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Orders(OrderID, DishID, Quantity)</em>:</p>
<div id="f10b5a41" class="cell" data-execution_count="41">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>O2001</td>
<td>A001</td>
<td>1</td>
</tr>
<tr class="even">
<td>O2002</td>
<td>A003</td>
<td>2</td>
</tr>
<tr class="odd">
<td>O2003</td>
<td>A005</td>
<td>1</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Menu</em> ⟖ <em>Orders</em> on <em>DishID</em> returns:</p>
<div id="552b1ee0" class="cell" data-execution_count="42">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">Dish</th>
<th data-quarto-table-cell-role="th">Price</th>
<th data-quarto-table-cell-role="th">OrderID</th>
<th data-quarto-table-cell-role="th">Quantity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Spring Roll</td>
<td>5.0</td>
<td>O2001</td>
<td>1</td>
</tr>
<tr class="even">
<td>A003</td>
<td>Sushi</td>
<td>10.0</td>
<td>O2002</td>
<td>2</td>
</tr>
<tr class="odd">
<td>A005</td>
<td>NaN</td>
<td>NaN</td>
<td>O2003</td>
<td>1</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This example demonstrates how a right outer join includes <strong>all rows from the right table</strong> (<code>Orders</code>), and the matching rows from the left table (<code>Menu</code>). If there is no match, <code>NULL</code> (or <code>NaN</code> in pandas) values are returned for the columns from the left table. Here, the <code>DishID: A005</code> from the <code>Orders</code> table does not exist in the <code>Menu</code>, so its corresponding <code>Dish</code> and <code>Price</code> columns have <code>NaN</code> values, but all orders are shown, even if the dish is not found on the menu.</p>
</div></div>
<!-- -->
</section>
<section id="full-outer-join-combining-data" class="slide level2">
<h2>Full Outer Join: Combining Data</h2>
<p>Full outer join returns all tuples from both relations, filling missing values with NULLs. It is the most inclusive join operation.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Full outer join returns all rows from both relations.</li>
<li>Non-matching rows from both sides are included.</li>
<li>Missing values are filled with NULLs for unmatched tuples.</li>
<li>This join is used when you need a complete set of data from both relations.</li>
<li>A powerful operation when analyzing two datasets with partial overlap.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Full outer join helps combine datasets completely, even if some data is missing.</em></p>
</section>
<section id="properties-of-the-full-outer-join-operator" class="slide level2">
<h2>Properties of the Full Outer Join Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
\begin{aligned}
R_1  \text{⟗}_{condition}  R_2 = &amp;{ t_1 , t_2 \mid t_1 \in R_1 \text{ and } t_2 \in R_2 \text{ and } condition(t_1, t_2) } \
&amp;\cup { t_1 \mid t_1 \in R_1 \text{ and no match in } R_2 } \
&amp;\cup { t_2 \mid t_2 \in R_2 \text{ and no match in } R_1 }
\end{aligned}
\]</span></p>
<ul>
<li>where <span class="math inline">\(t_1\)</span> is a row (tuple) from relation <span class="math inline">\(R_1\)</span>,</li>
<li><span class="math inline">\(t_2\)</span> is a row (tuple) from relation <span class="math inline">\(R_2\)</span>,</li>
<li>The <strong>full outer join</strong> combines rows from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> based on a specified <strong>join condition</strong>,</li>
<li>The result includes:
<ul>
<li>Rows where the join condition holds for both relations (matching rows),</li>
<li>Rows from <span class="math inline">\(R_1\)</span> with no matching rows in <span class="math inline">\(R_2\)</span> (padded with <code>NULL</code> values),</li>
<li>Rows from <span class="math inline">\(R_2\)</span> with no matching rows in <span class="math inline">\(R_1\)</span> (padded with <code>NULL</code> values).</li>
</ul></li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Commutative</strong> – The order of relations in a full outer join does not affect the result:</li>
</ul>
<p><span class="math display">\[
R_1  \text{⟗}_{condition}  R_2 = R_2  \text{⟗}_{condition}  R_1
\]</span></p>
<ul>
<li><strong>Associative</strong> – Grouping full outer join operations does not affect the result:</li>
</ul>
<p><span class="math display">\[
(R_1  \text{⟗}_{condition1}  R_2)  \text{⟗}_{condition2}  R_3 = R_1  \text{⟗}_{condition1}  (R_2  \text{⟗}_{condition2}  R_3)
\]</span></p>
<ul>
<li><strong>Full outer join with an empty set</strong> – The full outer join with an empty relation includes all rows from the non-empty relation, padded with <code>NULL</code> values for the other side:</li>
</ul>
<p><span class="math display">\[
R_1  \text{⟗}  \emptyset = R_1 \quad \text{(padded with `NULL` for } R_2\text{)}
\]</span></p>
<p><span class="math display">\[
\emptyset  \text{⟗}  R_2 = R_2 \quad \text{(padded with `NULL` for } R_1\text{)}
\]</span></p>
<ul>
<li><strong>Distributive over union</strong> – The full outer join is distributive over union:</li>
</ul>
<p><span class="math display">\[
R_1  \text{⟗}  (R_2 \cup R_3) = (R_1  \text{⟗}  R_2) \cup (R_1  \text{⟗}  R_3)
\]</span></p>
<ul>
<li><strong>Size of result</strong> – The size of the result is at most the sum of the rows in both relations, since all rows from both <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> are included, with unmatched rows padded with <code>NULL</code>.</li>
</ul>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-6" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Commutative</strong>: The order in which the relations are combined in a full outer join does not matter, as the result includes all rows from both relations.</li>
<li><strong>Associative</strong>: Grouping full outer joins differently does not affect the result, allowing the operation to be applied in stages.</li>
<li><strong>Full outer join with an empty set</strong>: If either relation is empty, the result includes all rows from the non-empty relation, with the other side padded with <code>NULL</code>.</li>
<li><strong>Distributive over union</strong>: Full outer join distributes over union, meaning you can break the join into smaller unions and join them separately.</li>
<li><strong>Size of result</strong>: The result contains all rows from both relations, so the number of rows is at most the sum of rows in <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, with <code>NULL</code> values used for non-matching rows.</li>
</ul>
<p>Here’s an example using a soccer team to demonstrate a <strong>Full Outer Join</strong>:</p>
</section>
<section id="full-outer-join-----example" class="slide level2">
<h2>Full Outer Join - ⋈ - Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Players(PlayerID, PlayerName, Position)</em>:</p>
<div id="0d3646de" class="cell" data-execution_count="44">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">PlayerID</th>
<th data-quarto-table-cell-role="th">PlayerName</th>
<th data-quarto-table-cell-role="th">Position</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P001</td>
<td>John</td>
<td>Forward</td>
</tr>
<tr class="even">
<td>P002</td>
<td>Alex</td>
<td>Midfielder</td>
</tr>
<tr class="odd">
<td>P003</td>
<td>Max</td>
<td>Defender</td>
</tr>
<tr class="even">
<td>P004</td>
<td>Luke</td>
<td>Goalkeeper</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Teams(TeamID, PlayerID, TeamName)</em>:</p>
<div id="83fc3c67" class="cell" data-execution_count="45">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">TeamID</th>
<th data-quarto-table-cell-role="th">PlayerID</th>
<th data-quarto-table-cell-role="th">TeamName</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T001</td>
<td>P001</td>
<td>Tigers</td>
</tr>
<tr class="even">
<td>T002</td>
<td>P003</td>
<td>Lions</td>
</tr>
<tr class="odd">
<td>T003</td>
<td>P005</td>
<td>Bears</td>
</tr>
<tr class="even">
<td>T004</td>
<td>P006</td>
<td>Wolves</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Players</em> ⋈ <em>Teams</em> on <em>PlayerID</em> returns:</p>
<div id="f9c8d1b8" class="cell" data-execution_count="46">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">PlayerID</th>
<th data-quarto-table-cell-role="th">PlayerName</th>
<th data-quarto-table-cell-role="th">Position</th>
<th data-quarto-table-cell-role="th">TeamID</th>
<th data-quarto-table-cell-role="th">TeamName</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P001</td>
<td>John</td>
<td>Forward</td>
<td>T001</td>
<td>Tigers</td>
</tr>
<tr class="even">
<td>P002</td>
<td>Alex</td>
<td>Midfielder</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td>P003</td>
<td>Max</td>
<td>Defender</td>
<td>T002</td>
<td>Lions</td>
</tr>
<tr class="even">
<td>P004</td>
<td>Luke</td>
<td>Goalkeeper</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td>P005</td>
<td>NaN</td>
<td>NaN</td>
<td>T003</td>
<td>Bears</td>
</tr>
<tr class="even">
<td>P006</td>
<td>NaN</td>
<td>NaN</td>
<td>T004</td>
<td>Wolves</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This example demonstrates how a full outer join combines all rows from both tables (<code>Players</code> and <code>Teams</code>), with matches being displayed where available. If a player does not belong to a team or a team does not have a listed player, <code>NULL</code> (or <code>NaN</code> in pandas) values are filled in for missing information. For example, players <code>P005</code> and <code>P006</code> exist only in the <code>Teams</code> table, and players <code>P002</code> and <code>P004</code> exist only in the <code>Players</code> table. The full outer join will include all records from both tables.</p>
</div></div>
<!-- -->
<p>Here’s another example using cameras and images to demonstrate a <strong>Full Outer Join</strong>:</p>
</section>
<section id="full-outer-join-----example-1" class="slide level2">
<h2>Full Outer Join - ⋈ - Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Cameras(CameraID, CameraModel, LensType)</em>:</p>
<div id="44d98c26" class="cell" data-execution_count="48">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">CameraID</th>
<th data-quarto-table-cell-role="th">CameraModel</th>
<th data-quarto-table-cell-role="th">LensType</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C001</td>
<td>Canon EOS</td>
<td>50mm</td>
</tr>
<tr class="even">
<td>C002</td>
<td>Nikon D3500</td>
<td>18-55mm</td>
</tr>
<tr class="odd">
<td>C003</td>
<td>Sony Alpha</td>
<td>35mm</td>
</tr>
<tr class="even">
<td>C004</td>
<td>Fujifilm XT3</td>
<td>24-70mm</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Images(ImageID, CameraID, ImageDescription)</em>:</p>
<div id="71f5ad4b" class="cell" data-execution_count="49">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">ImageID</th>
<th data-quarto-table-cell-role="th">CameraID</th>
<th data-quarto-table-cell-role="th">ImageDescription</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I001</td>
<td>C001</td>
<td>Landscape</td>
</tr>
<tr class="even">
<td>I002</td>
<td>C003</td>
<td>Portrait</td>
</tr>
<tr class="odd">
<td>I003</td>
<td>C005</td>
<td>Macro</td>
</tr>
<tr class="even">
<td>I004</td>
<td>C006</td>
<td>Night Sky</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Cameras</em> ⋈ (<em>CameraID</em>) <em>Images</em> returns:</p>
<div id="7ae4c577" class="cell" data-execution_count="50">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">CameraID</th>
<th data-quarto-table-cell-role="th">CameraModel</th>
<th data-quarto-table-cell-role="th">LensType</th>
<th data-quarto-table-cell-role="th">ImageID</th>
<th data-quarto-table-cell-role="th">ImageDescription</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C001</td>
<td>Canon EOS</td>
<td>50mm</td>
<td>I001</td>
<td>Landscape</td>
</tr>
<tr class="even">
<td>C002</td>
<td>Nikon D3500</td>
<td>18-55mm</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td>C003</td>
<td>Sony Alpha</td>
<td>35mm</td>
<td>I002</td>
<td>Portrait</td>
</tr>
<tr class="even">
<td>C004</td>
<td>Fujifilm XT3</td>
<td>24-70mm</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td>C005</td>
<td>NaN</td>
<td>NaN</td>
<td>I003</td>
<td>Macro</td>
</tr>
<tr class="even">
<td>C006</td>
<td>NaN</td>
<td>NaN</td>
<td>I004</td>
<td>Night Sky</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This full outer join combines all rows from both the <code>Cameras</code> and <code>Images</code> tables. Where there is a matching <code>CameraID</code>, the corresponding camera and image details are shown. For unmatched <code>CameraID</code>s (such as <code>C005</code> and <code>C006</code> from the <code>Images</code> table and <code>C002</code> and <code>C004</code> from the <code>Cameras</code> table), <code>NULL</code> (or <code>NaN</code>) values fill in the missing data. This query provides a complete view of all cameras and all images, regardless of whether they have a match in the other table.</p>
</div></div>
<!-- -->
</section>
<section id="natural-join-definition-and-application" class="slide level2">
<h2>Natural Join: Definition and Application</h2>
<p>A natural join automatically matches attributes with the same name in both relations, simplifying queries when attribute names align.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Natural join matches tuples based on attributes with the same name.</li>
<li>No explicit join condition is needed.</li>
<li>Automatically merges common columns.</li>
<li>Useful when attribute names are consistent across relations.</li>
<li>Simplifies queries by eliminating the need for specifying the join condition.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Natural join is a convenient way to join relations when common attribute names are used.</em></p>
</section>
<section id="properties-of-the-natural-join-operator" class="slide level2">
<h2>Properties of the Natural Join Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \bowtie R_2 = { t_1 , t_2 \mid t_1 \in R_1, t_2 \in R_2, \text{ and for all common attributes } A, t_1\[A\] = t_2\[A\] }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t_1\)</span> is a row (tuple) from relation <span class="math inline">\(R_1\)</span>,</li>
<li><span class="math inline">\(t_2\)</span> is a row (tuple) from relation <span class="math inline">\(R_2\)</span>,</li>
<li>The <strong>natural join</strong> operation joins two relations based on all attributes they have in common, combining rows where the values of the common attributes are equal,</li>
<li>The result contains only the attributes from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, but common attributes appear only once.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Commutative</strong> – The order of relations in a natural join does not affect the result:</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie R_2 = R_2 \bowtie R_1
\]</span></p>
<ul>
<li><strong>Associative</strong> – Grouping natural join operations does not affect the result:</li>
</ul>
<p><span class="math display">\[
(R_1 \bowtie R_2) \bowtie R_3 = R_1 \bowtie (R_2 \bowtie R_3)
\]</span></p>
<ul>
<li><strong>Natural join with an empty set</strong> – The natural join with an empty relation results in an empty set:</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie \emptyset = \emptyset
\]</span></p>
<ul>
<li><strong>Natural join distributes over selection</strong> – The natural join distributes over selection operations when the selection condition involves attributes from one of the relations:</li>
</ul>
<p><span class="math display">\[
\sigma_{condition}(R_1 \bowtie R_2) = \sigma_{condition}(R_1) \bowtie R_2
\]</span> (if the selection condition applies to attributes of <span class="math inline">\(R_1\)</span> only)</p>
<ul>
<li><strong>Size of result</strong> – The size of the result depends on how many rows in <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> match based on the values of the common attributes.</li>
</ul>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-7" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Commutative</strong>: The order of relations in the natural join does not matter, as the result includes matching rows from both relations based on their common attributes.</li>
<li><strong>Associative</strong>: Grouping natural joins differently does not affect the result, allowing the operation to be applied in stages.</li>
<li><strong>Natural join with an empty set</strong>: If either relation is empty, the result will also be empty, as there are no rows to match.</li>
<li><strong>Natural join distributes over selection</strong>: You can apply a selection condition to one relation before performing the natural join without affecting the outcome, provided the condition applies only to attributes from that relation.</li>
<li><strong>Size of result</strong>: The result includes all rows from both relations where the values of common attributes match, and the number of matching rows determines the size of the result.</li>
</ul>
<p>Here’s an example using a <strong>Natural Join</strong> with a kennel and dog data set.</p>
</section>
<section id="natural-join-example" class="slide level2">
<h2>Natural Join Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Dogs(DogID, Name, Breed, Age)</em>:</p>
<div id="441e9c91" class="cell" data-execution_count="52">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DogID</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Breed</th>
<th data-quarto-table-cell-role="th">Age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D101</td>
<td>Buddy</td>
<td>Labrador</td>
<td>3</td>
</tr>
<tr class="even">
<td>D102</td>
<td>Bella</td>
<td>Beagle</td>
<td>4</td>
</tr>
<tr class="odd">
<td>D103</td>
<td>Charlie</td>
<td>Poodle</td>
<td>2</td>
</tr>
<tr class="even">
<td>D104</td>
<td>Lucy</td>
<td>Bulldog</td>
<td>5</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Kennels(DogID, KennelID, ArrivalDate)</em>:</p>
<div id="2811c8be" class="cell" data-execution_count="53">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DogID</th>
<th data-quarto-table-cell-role="th">KennelID</th>
<th data-quarto-table-cell-role="th">ArrivalDate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D101</td>
<td>K001</td>
<td>2024-01-10</td>
</tr>
<tr class="even">
<td>D103</td>
<td>K002</td>
<td>2024-02-15</td>
</tr>
<tr class="odd">
<td>D105</td>
<td>K003</td>
<td>2024-03-20</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Dogs</em> <span class="math inline">\(\bowtie\)</span> <em>Kennels</em> on <em>DogID</em> returns:</p>
<div id="58a34b41" class="cell" data-execution_count="54">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DogID</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Breed</th>
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">KennelID</th>
<th data-quarto-table-cell-role="th">ArrivalDate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D101</td>
<td>Buddy</td>
<td>Labrador</td>
<td>3</td>
<td>K001</td>
<td>2024-01-10</td>
</tr>
<tr class="even">
<td>D103</td>
<td>Charlie</td>
<td>Poodle</td>
<td>2</td>
<td>K002</td>
<td>2024-02-15</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>In a <strong>Natural Join</strong>, the join is based on columns with the same name and automatically combines rows with matching values in those columns. In this case, both tables have the column <code>DogID</code>, so a natural join combines the <code>dogs</code> and <code>kennels</code> data where <code>DogID</code> matches. Only the dogs with a corresponding kennel entry (<code>DogID: D101</code> and <code>D103</code>) are included in the result, while unmatched dogs and kennels are excluded.</p>
</div></div>
<!-- -->
</section>
<section id="natural-join---example-with-two-overlapping-columns" class="slide level2">
<h2>Natural Join - Example with Two Overlapping Columns</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Buses(BusID, Route, Capacity, DriverID)</em>:</p>
<div id="96d6e026" class="cell" data-execution_count="56">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">BusID</th>
<th data-quarto-table-cell-role="th">Route</th>
<th data-quarto-table-cell-role="th">Capacity</th>
<th data-quarto-table-cell-role="th">DriverID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B001</td>
<td>101</td>
<td>50</td>
<td>D001</td>
</tr>
<tr class="even">
<td>B002</td>
<td>102</td>
<td>45</td>
<td>D002</td>
</tr>
<tr class="odd">
<td>B003</td>
<td>103</td>
<td>60</td>
<td>D003</td>
</tr>
<tr class="even">
<td>B004</td>
<td>104</td>
<td>40</td>
<td>D004</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Passengers(PassengerID, BusID, DriverID, Seat)</em>:</p>
<div id="6779a614" class="cell" data-execution_count="57">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">PassengerID</th>
<th data-quarto-table-cell-role="th">BusID</th>
<th data-quarto-table-cell-role="th">DriverID</th>
<th data-quarto-table-cell-role="th">Seat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>P101</td>
<td>B001</td>
<td>D001</td>
<td>12</td>
</tr>
<tr class="even">
<td>P102</td>
<td>B003</td>
<td>D003</td>
<td>18</td>
</tr>
<tr class="odd">
<td>P103</td>
<td>B002</td>
<td>D002</td>
<td>9</td>
</tr>
<tr class="even">
<td>P104</td>
<td>B005</td>
<td>D006</td>
<td>5</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Buses</em> <span class="math inline">\(\bowtie\)</span> <em>Passengers</em> on <em>BusID</em> and <em>DriverID</em> returns:</p>
<div id="3fa60c55" class="cell" data-execution_count="58">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">BusID</th>
<th data-quarto-table-cell-role="th">Route</th>
<th data-quarto-table-cell-role="th">Capacity</th>
<th data-quarto-table-cell-role="th">DriverID</th>
<th data-quarto-table-cell-role="th">PassengerID</th>
<th data-quarto-table-cell-role="th">Seat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B001</td>
<td>101</td>
<td>50</td>
<td>D001</td>
<td>P101</td>
<td>12</td>
</tr>
<tr class="even">
<td>B002</td>
<td>102</td>
<td>45</td>
<td>D002</td>
<td>P103</td>
<td>9</td>
</tr>
<tr class="odd">
<td>B003</td>
<td>103</td>
<td>60</td>
<td>D003</td>
<td>P102</td>
<td>18</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>In this <strong>Natural Join</strong>, we are joining on two columns that both tables have in common: <code>BusID</code> and <code>DriverID</code>. The join automatically combines rows where both the <code>BusID</code> <strong>and</strong> <code>DriverID</code> match. This natural join will return only rows where both the bus and passenger data have matching <code>BusID</code> and <code>DriverID</code>. In this case, it will exclude any buses or passengers where these two columns do not match simultaneously.</p>
</div></div>
<!-- -->
</section>
<section id="theta-join-flexibility-with-conditions" class="slide level2">
<h2>Theta Join: Flexibility with Conditions</h2>
<p>Theta join allows the use of arbitrary conditions to combine relations, offering flexibility beyond just equality conditions.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Theta join applies a condition other than equality to combine relations.</li>
<li>The condition can be any comparison operator (e.g., &lt;, &gt;, =).</li>
<li>More flexible than natural or inner joins.</li>
<li>Useful when a relationship between tuples is based on non-equality conditions.</li>
<li>Examples include finding tuples where one attribute is greater than another.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Theta join provides flexibility in combining relations using complex conditions.</em></p>
</section>
<section id="properties-of-the-theta-join-operator" class="slide level2">
<h2>Properties of the Theta Join Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \bowtie_{\theta} R_2 = { t_1 , t_2 \mid t_1 \in R_1, t_2 \in R_2, \text{ and } \theta(t_1, t_2) = \text{true} }
\]</span></p>
<ul>
<li>where <span class="math inline">\(t_1\)</span> is a row (tuple) from relation <span class="math inline">\(R_1\)</span>,</li>
<li><span class="math inline">\(t_2\)</span> is a row (tuple) from relation <span class="math inline">\(R_2\)</span>,</li>
<li><span class="math inline">\(\theta\)</span> is a <strong>predicate</strong> (condition) that can be any comparison expression involving the attributes of <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, such as <span class="math inline">\(=, \neq, \&lt;, &gt;, \leq, \geq\)</span>,</li>
<li>The <strong>theta join</strong> combines rows from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> where the condition <span class="math inline">\(\theta\)</span> holds true for both relations.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Non-commutative</strong> – The order of relations in a theta join matters (unless the predicate is symmetric):</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie_{\theta} R_2 \neq R_2 \bowtie_{\theta} R_1
\]</span> (unless <span class="math inline">\(\theta(t_1, t_2) = \theta(t_2, t_1)\)</span>)</p>
<ul>
<li><strong>Associative</strong> – Grouping theta join operations depends on the predicates but generally holds true:</li>
</ul>
<p><span class="math display">\[
(R_1 \bowtie_{\theta_1} R_2) \bowtie_{\theta_2} R_3 = R_1 \bowtie_{\theta_1} (R_2 \bowtie_{\theta_2} R_3)
\]</span> (if the conditions <span class="math inline">\(\theta_1\)</span> and <span class="math inline">\(\theta_2\)</span> are consistent)</p>
<ul>
<li><strong>Theta join with an empty set</strong> – The theta join with an empty relation results in an empty set:</li>
</ul>
<p><span class="math display">\[
R_1 \bowtie_{\theta} \emptyset = \emptyset
\]</span></p>
<ul>
<li><strong>Theta join distributes over selection</strong> – The theta join distributes over selection when the selection condition involves only attributes from one of the relations:</li>
</ul>
<p><span class="math display">\[
\sigma_{condition}(R_1 \bowtie_{\theta} R_2) = \sigma_{condition}(R_1) \bowtie_{\theta} R_2
\]</span> (if the selection condition applies to attributes of <span class="math inline">\(R_1\)</span> only)</p>
<ul>
<li><strong>Size of result</strong> – The size of the result depends on how many rows in <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> satisfy the predicate <span class="math inline">\(\theta\)</span>.</li>
</ul>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-8" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Non-commutative</strong>: The order of relations in the theta join matters unless the predicate <span class="math inline">\(\theta\)</span> is symmetric, meaning <span class="math inline">\(R_1 \bowtie_{\theta} R_2\)</span> will not necessarily equal <span class="math inline">\(R_2 \bowtie_{\theta} R_1\)</span>.</li>
<li><strong>Associative</strong>: Grouping theta joins with different predicates can affect the result, but when consistent conditions are applied, associativity holds.</li>
<li><strong>Theta join with an empty set</strong>: If either relation is empty, the result of the theta join is empty because there are no rows to compare.</li>
<li><strong>Theta join distributes over selection</strong>: You can apply a selection condition to one relation before performing the theta join without affecting the result, provided the selection applies only to that relation.</li>
<li><strong>Size of result</strong>: The number of rows in the result depends on how many rows from <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span> satisfy the condition <span class="math inline">\(\theta\)</span>.</li>
</ul>
<p>This structure mirrors the format of previous relational algebra operations, focusing on the flexibility and behavior of the theta join, where any comparison operator can be used in the join condition.</p>
<p>Here’s an example of a <strong>Theta Join</strong> using an authors and books model. In this case, the Theta Join will be based on a condition, such as comparing the number of books an author has written to a certain threshold.</p>
</section>
<section id="theta-join-example" class="slide level2">
<h2>Theta Join Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Authors(AuthorID, AuthorName, BooksWritten)</em>:</p>
<div id="e38dac15" class="cell" data-execution_count="60">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">AuthorID</th>
<th data-quarto-table-cell-role="th">AuthorName</th>
<th data-quarto-table-cell-role="th">BooksWritten</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Alice</td>
<td>5</td>
</tr>
<tr class="even">
<td>A002</td>
<td>Bob</td>
<td>2</td>
</tr>
<tr class="odd">
<td>A003</td>
<td>Charlie</td>
<td>8</td>
</tr>
<tr class="even">
<td>A004</td>
<td>Diana</td>
<td>3</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Books(BookID, AuthorID, Title)</em>:</p>
<div id="bd1aba71" class="cell" data-execution_count="61">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">BookID</th>
<th data-quarto-table-cell-role="th">AuthorID</th>
<th data-quarto-table-cell-role="th">Title</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B001</td>
<td>A001</td>
<td>Data Science 101</td>
</tr>
<tr class="even">
<td>B002</td>
<td>A002</td>
<td>Math Fundamentals</td>
</tr>
<tr class="odd">
<td>B003</td>
<td>A003</td>
<td>Advanced Python</td>
</tr>
<tr class="even">
<td>B004</td>
<td>A003</td>
<td>Machine Learning</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Authors</em> ⨝ θ <em>Books</em> where <em>BooksWritten &gt; 3</em>:</p>
<div id="98549422" class="cell" data-execution_count="62">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">AuthorID</th>
<th data-quarto-table-cell-role="th">AuthorName</th>
<th data-quarto-table-cell-role="th">BooksWritten</th>
<th data-quarto-table-cell-role="th">BookID</th>
<th data-quarto-table-cell-role="th">Title</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A001</td>
<td>Alice</td>
<td>5</td>
<td>B001</td>
<td>Data Science 101</td>
</tr>
<tr class="even">
<td>A003</td>
<td>Charlie</td>
<td>8</td>
<td>B003</td>
<td>Advanced Python</td>
</tr>
<tr class="odd">
<td>A003</td>
<td>Charlie</td>
<td>8</td>
<td>B004</td>
<td>Machine Learning</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>In this <strong>Theta Join</strong>, we apply a condition (<code>BooksWritten &gt; 3</code>) to filter the authors, then join the result with the <code>Books</code> table on the common column <code>AuthorID</code>. This example only includes authors who have written more than 3 books and returns their associated books.</p>
</div></div>
<!-- -->
<p>Here’s another example of a <strong>Theta Join</strong> using a video game store and video game model. This Theta Join will be based on a condition, such as comparing the price of video games to a certain threshold.</p>
</section>
<section id="theta-join-example-2" class="slide level2">
<h2>Theta Join Example 2</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Stores(StoreID, StoreName, Location)</em>:</p>
<div id="a00555b7" class="cell" data-execution_count="64">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">StoreID</th>
<th data-quarto-table-cell-role="th">StoreName</th>
<th data-quarto-table-cell-role="th">Location</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S001</td>
<td>Game Galaxy</td>
<td>Downtown</td>
</tr>
<tr class="even">
<td>S002</td>
<td>Retro Station</td>
<td>Suburbs</td>
</tr>
<tr class="odd">
<td>S003</td>
<td>Pixel Paradise</td>
<td>City Center</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>Games(GameID, StoreID, GameTitle, Price)</em>:</p>
<div id="6d6ad72c" class="cell" data-execution_count="65">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">GameID</th>
<th data-quarto-table-cell-role="th">StoreID</th>
<th data-quarto-table-cell-role="th">GameTitle</th>
<th data-quarto-table-cell-role="th">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>G001</td>
<td>S001</td>
<td>Super Smash</td>
<td>60</td>
</tr>
<tr class="even">
<td>G002</td>
<td>S001</td>
<td>Zelda Quest</td>
<td>50</td>
</tr>
<tr class="odd">
<td>G003</td>
<td>S002</td>
<td>Mario Kart</td>
<td>55</td>
</tr>
<tr class="even">
<td>G004</td>
<td>S003</td>
<td>Fortnite</td>
<td>20</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><em>Stores</em> ⨝ θ (<em>Price &gt; 50</em>) <em>Games</em> return :</p>
<div id="91f8ecae" class="cell" data-execution_count="66">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">StoreID</th>
<th data-quarto-table-cell-role="th">StoreName</th>
<th data-quarto-table-cell-role="th">Location</th>
<th data-quarto-table-cell-role="th">GameID</th>
<th data-quarto-table-cell-role="th">GameTitle</th>
<th data-quarto-table-cell-role="th">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S001</td>
<td>Game Galaxy</td>
<td>Downtown</td>
<td>G001</td>
<td>Super Smash</td>
<td>60</td>
</tr>
<tr class="even">
<td>S002</td>
<td>Retro Station</td>
<td>Suburbs</td>
<td>G003</td>
<td>Mario Kart</td>
<td>55</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>In this <strong>Theta Join</strong>, we apply a condition (<code>Price &gt; 50</code>) to filter the video games, then join the result with the <code>Stores</code> table on the common column <code>StoreID</code>. This example only includes games that are priced above $50 and returns the store details for those games.</p>
<p>For instance, only games like <code>Super Smash</code> and <code>Mario Kart</code> will be included in the result, along with the corresponding stores. Games priced $50 or below (like <code>Fortnite</code>) are excluded from the result.</p>
</div></div>
<!-- -->
</section>
<section id="use-cases-inner-join" class="slide level2">
<h2>Use Cases: Inner Join</h2>
<p>Inner join is commonly used in scenarios where you only need matching data from two relations. It’s ideal for combining related data.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Frequently used when matching foreign keys with primary keys.</li>
<li>Example: retrieving student records with matching course registrations.</li>
<li>Ideal for filtering data to include only relevant, connected records.</li>
<li>Used when non-matching data is not important for the query.</li>
<li>Popular in most applications like finance, HR, and inventory systems.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Inner join is ideal when you only care about related records from two relations.</em></p>
</section>
<section id="use-cases-left-and-right-outer-joins" class="slide level2">
<h2>Use Cases: Left and Right Outer Joins</h2>
<p>Outer joins are useful when you want to keep all records from one side, even if they don’t have a match in the other relation.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Left outer join is often used in master-detail relationships.</li>
<li>Example: retrieving all customers and their orders, including customers without orders.</li>
<li>Right outer join can be used when focusing on all records from a detail table.</li>
<li>Used when incomplete data is acceptable, such as optional relationships.</li>
<li>Often used in customer management systems to track unfilled orders.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Left and right outer joins are valuable when you need non-matching data from one side.</em></p>
</section>
<section id="use-cases-full-outer-join" class="slide level2">
<h2>Use Cases: Full Outer Join</h2>
<p>Full outer join is used in scenarios where you need to retain all data, even if some entries don’t match. This join is comprehensive.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Often used in data integration tasks.</li>
<li>Example: merging two datasets where both may contain unmatched records.</li>
<li>Used in scenarios like combining employee records from different departments.</li>
<li>Useful in data warehousing and analytics to ensure no data is lost.</li>
<li>Common in reconciling data from different sources with partial overlap.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Full outer join ensures no data is lost when combining two relations with missing matches.</em></p>
</section>
<section id="combining-joins-for-complex-queries" class="slide level2">
<h2>Combining Joins for Complex Queries</h2>
<p>Different join types can be combined to solve complex queries involving multiple relations. This is often used in real-world database systems.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Inner and outer joins can be combined in complex queries.</li>
<li>Example: joining multiple relations with inner joins, then an outer join to fill gaps.</li>
<li>Different join types solve different parts of the same query.</li>
<li>Used in multi-table queries for comprehensive data retrieval.</li>
<li>Often seen in reporting systems that need complete data coverage.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Combining join operations allows complex queries that satisfy multiple data needs.</em></p>
</section></section>
<section>
<section id="renaming-and-division" class="title-slide slide level1 center">
<h1>Renaming and Division</h1>
<!-- # Renaming and Division -->
</section>
<section id="renaming-in-relational-algebra" class="slide level2">
<h2>Renaming in Relational Algebra</h2>
<p>Renaming allows the assignment of new names to relations or attributes, making complex queries easier to understand. This operation helps avoid ambiguities, especially in self-joins or when handling multiple relations.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Renaming provides a way to assign new names to relations and their attributes.</li>
<li>The <code>ρ</code> (rho) operator is used for renaming in relational algebra.</li>
<li>Syntax: <code>ρ(new_name(old_name))</code> for renaming relations.</li>
<li>Renaming is essential when performing self-joins to avoid confusion.</li>
<li>It allows for clearer queries when dealing with complex or long attribute names.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Renaming enhances clarity in query design, especially when handling multiple relations.</em></p>
<p>Here’s the definition and properties of the <strong>renaming</strong> operation in relational algebra, formatted similarly to the template you provided:</p>
</section>
<section id="properties-of-the-renaming-operator" class="slide level2">
<h2>Properties of the Renaming Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
\rho_{new_name}(R) = { t \mid t \in R }
\]</span></p>
<ul>
<li>where <span class="math inline">\(R\)</span> is a relation (table),</li>
<li><span class="math inline">\(new_name\)</span> is the new name assigned to relation <span class="math inline">\(R\)</span> or one or more of its attributes,</li>
<li>The <strong>renaming</strong> operation is used to assign a new name to either the entire relation or to individual attributes in the relation, preserving the structure and data,</li>
<li>It allows us to avoid ambiguity in cases where relations have overlapping attribute names or when working with complex queries.</li>
</ul>
<p>The renaming operation can be used in three forms:</p>
<ul>
<li>Renaming the entire relation: <span class="math inline">\(\rho_{S}(R)\)</span> renames relation <span class="math inline">\(R\)</span> to <span class="math inline">\(S\)</span>,</li>
<li>Renaming attributes: <span class="math inline">\(\rho_{(A_1 \rightarrow B_1, A_2 \rightarrow B_2, \dots)}(R)\)</span> renames the attributes <span class="math inline">\(A_1, A_2, \dots\)</span> in <span class="math inline">\(R\)</span> to <span class="math inline">\(B_1, B_2, \dots\)</span>,</li>
<li>Renaming both the relation and its attributes: <span class="math inline">\(\rho_{S(A_1 \rightarrow B_1, A_2 \rightarrow B_2, \dots)}(R)\)</span>.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Idempotent</strong> – Renaming a relation or attribute multiple times with the same name does not change the result:</li>
</ul>
<p><span class="math display">\[
\rho_{new_name}(\rho_{new_name}(R)) = \rho_{new_name}(R)
\]</span></p>
<ul>
<li><strong>Non-commutative</strong> – The order of renaming different attributes matters:</li>
</ul>
<p><span class="math display">\[
\rho_{(A \rightarrow B)}(\rho_{(B \rightarrow C)}(R)) \neq \rho_{(B \rightarrow C)}(\rho_{(A \rightarrow B)}(R))
\]</span></p>
<ul>
<li><strong>Associative</strong> – Renaming operations can be grouped without affecting the result:</li>
</ul>
<p><span class="math display">\[
\rho_{new_name_1}(\rho_{new_name_2}(R)) = \rho_{new_name_2}(\rho_{new_name_1}(R))
\]</span></p>
<ul>
<li><strong>Renaming with an empty set</strong> – Renaming an empty relation still results in an empty set:</li>
</ul>
<p><span class="math display">\[
\rho_{new_name}(\emptyset) = \emptyset
\]</span></p>
<ul>
<li><strong>Renaming preserves all rows and attributes</strong> – The renaming operation only changes names and does not affect the content or structure of the relation:</li>
</ul>
<p><span class="math display">\[
|R| = |\rho_{new_name}(R)|
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation-of-properties-9" class="slide level2">
<h2>Explanation of properties</h2>
<ul>
<li><strong>Idempotent</strong>: Renaming a relation or attribute multiple times with the same name has no additional effect.</li>
<li><strong>Non-commutative</strong>: The order in which you rename attributes matters, especially if the renaming involves the same attribute multiple times.</li>
<li><strong>Associative</strong>: Renaming operations can be applied in any order, provided they refer to different attributes or relation names.</li>
<li><strong>Renaming with an empty set</strong>: If the relation is empty, renaming it will still result in an empty relation.</li>
<li><strong>Renaming preserves all rows and attributes</strong>: The renaming operation only affects the labels of relations and attributes, not their content or structure, so the number of rows and attributes remains unchanged.</li>
</ul>
</section>
<section id="example-of-renaming-in-queries" class="slide level2">
<h2>Example of Renaming in Queries</h2>
<p>Renaming becomes critical when performing operations like joins, ensuring that attribute names are distinct. This slide provides a simple renaming example to illustrate its importance.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Example: <code>ρ(S(Age -&gt; StudentAge))</code> renames the attribute <code>Age</code> to <code>StudentAge</code> in relation <code>S</code>.</li>
<li>Used to avoid name clashes during operations such as joins.</li>
<li>Provides a way to clarify attribute roles in a query.</li>
<li>Enables more readable queries in complex databases.</li>
<li>Essential when working with relations that have identical attribute names.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Renaming is a flexible tool for improving query readability and structure.</em></p>
</section>
<section id="introduction-to-division-in-relational-algebra" class="slide level2">
<h2>Introduction to Division in Relational Algebra</h2>
<p>Division is a specialized relational operation used to retrieve tuples that match all combinations of a related set. It is particularly useful when you need to find records related to every value in another relation.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Division is used to query for entities that are related to all values in a subset.</li>
<li>The operation works on two relations: a dividend and a divisor.</li>
<li>It returns tuples from the dividend that are associated with all tuples in the divisor.</li>
<li>Typically used in “all” queries, such as “students enrolled in all courses.”</li>
<li>Not as common as basic operations but vital in certain query types.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Division is a powerful but specific operation that allows querying for “all related” records.</em></p>
</section>
<section id="properties-of-the-division-operator" class="slide level2">
<h2>Properties of the Division Operator</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p><strong>Definition</strong></p>
<p><span class="math display">\[
R_1 \div R_2 = { t_1 \mid t_1 \in \pi_{A}(R_1) \text{ and for every } t_2 \in R_2, (t_1, t_2) \in R_1 }
\]</span></p>
<ul>
<li>where <span class="math inline">\(R_1\)</span> is a relation with attributes <span class="math inline">\(A \cup B\)</span>,</li>
<li><span class="math inline">\(R_2\)</span> is a relation with attributes <span class="math inline">\(B\)</span> (a subset of <span class="math inline">\(R_1\)</span>’s attributes),</li>
<li>The <strong>division</strong> operation returns a new relation consisting of the values of <span class="math inline">\(A\)</span> from <span class="math inline">\(R_1\)</span> that match every tuple in <span class="math inline">\(R_2\)</span>,</li>
<li>Essentially, division finds the tuples in <span class="math inline">\(R_1\)</span> that have a corresponding match for every tuple in <span class="math inline">\(R_2\)</span>.</li>
</ul>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p><strong>Properties</strong></p>
<ul>
<li><strong>Not commutative</strong> – The order of relations in the division operation matters:</li>
</ul>
<p><span class="math display">\[
R_1 \div R_2 \neq R_2 \div R_1
\]</span></p>
<ul>
<li><strong>Non-associative</strong> – Division is not associative:</li>
</ul>
<p><span class="math display">\[
(R_1 \div R_2) \div R_3 \neq R_1 \div (R_2 \div R_3)
\]</span></p>
<ul>
<li><strong>Division with an empty set</strong> – If <span class="math inline">\(R_2\)</span> is an empty set, the division result is the projection of <span class="math inline">\(R_1\)</span> on <span class="math inline">\(A\)</span>:</li>
</ul>
<p><span class="math display">\[
R_1 \div \emptyset = \pi_{A}(R_1)
\]</span></p>
<ul>
<li><strong>Division with itself</strong> – Dividing a relation by itself results in an empty set unless <span class="math inline">\(R_2\)</span> contains only tuples present in <span class="math inline">\(R_1\)</span>:</li>
</ul>
<p><span class="math display">\[
R_1 \div R_1 = \emptyset \quad \text{(if } R_1 \text{ and } R_2 \text{ are identical and non-empty)}
\]</span></p>
<ul>
<li><strong>Division with a superset</strong> – If <span class="math inline">\(R_2\)</span> is a superset of <span class="math inline">\(B\)</span>-values in <span class="math inline">\(R_1\)</span>, the result is empty:</li>
</ul>
<p><span class="math display">\[
R_1 \div R_2 = \emptyset \quad \text{(if } \pi_B(R_2) \not\subseteq \pi_B(R_1))
\]</span></p>
</div></div>
<!-- -->
</section>
<section id="explanation" class="slide level2">
<h2>Explanation:</h2>
<ul>
<li><strong>Not commutative</strong>: The order of relations in the division operation matters, as dividing one relation by another is not symmetric.</li>
<li><strong>Non-associative</strong>: Division is not associative, meaning that the order in which you perform multiple division operations can affect the result.</li>
<li><strong>Division with an empty set</strong>: If <span class="math inline">\(R_2\)</span> is empty, the result is the projection of <span class="math inline">\(R_1\)</span> on <span class="math inline">\(A\)</span>, as no conditions exist for <span class="math inline">\(B\)</span> attributes.</li>
<li><strong>Division with itself</strong>: Dividing a relation by itself typically results in an empty set unless all tuples from <span class="math inline">\(R_2\)</span> are in <span class="math inline">\(R_1\)</span>.</li>
<li><strong>Division with a superset</strong>: If <span class="math inline">\(R_2\)</span> contains values that don’t appear in <span class="math inline">\(R_1\)</span>, the result is empty since no <span class="math inline">\(A\)</span>-values in <span class="math inline">\(R_1\)</span> satisfy the matching condition for all tuples in <span class="math inline">\(R_2\)</span>.</li>
</ul>
</section>
<section id="division-syntax-and-example" class="slide level2">
<h2>Division: Syntax and Example</h2>
<p>Division can be represented using the <code>/</code> operator between two relations. Understanding how this operator works in practice will help you apply it correctly.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Syntax: <code>R / S</code> where <code>R</code> is the dividend and <code>S</code> is the divisor.</li>
<li>Example: Find students enrolled in all mandatory courses: <code>StudentCourses / MandatoryCourses</code>.</li>
<li>Involves projecting attributes from <code>R</code> that do not appear in <code>S</code>.</li>
<li>Often paired with set difference to exclude unwanted tuples.</li>
<li>Typically used when one relation defines a subset of another relation’s attributes.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>The division operator retrieves records that match a complete set of conditions across relations.</em></p>
<p>Here’s the <strong>division</strong> relational operator example using the template format you provided earlier:</p>
</section>
<section id="division-----example" class="slide level2">
<h2>Division - ÷ - Example</h2>
<div class="columns">
<div class="column" style="width:47%;">
<p>Given <em>Customers(CustomerID, DishID)</em>:</p>
<div id="d0d7c7b3" class="cell" data-execution_count="68">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">CustomerID</th>
<th data-quarto-table-cell-role="th">DishID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C001</td>
<td>D001</td>
</tr>
<tr class="even">
<td>C001</td>
<td>D002</td>
</tr>
<tr class="odd">
<td>C002</td>
<td>D001</td>
</tr>
<tr class="even">
<td>C002</td>
<td>D002</td>
</tr>
<tr class="odd">
<td>C002</td>
<td>D003</td>
</tr>
<tr class="even">
<td>C003</td>
<td>D001</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>and <em>DimSum(DishID, DishName)</em>:</p>
<div id="c02fca9d" class="cell" data-execution_count="69">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">DishID</th>
<th data-quarto-table-cell-role="th">DishName</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D001</td>
<td>Siu Mai</td>
</tr>
<tr class="even">
<td>D002</td>
<td>Har Gow</td>
</tr>
<tr class="odd">
<td>D003</td>
<td>Char Siu Bao</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
</div><div class="column" style="width:6%;">

</div><div class="column" style="width:47%;">
<p>Find the customers who have ordered all dim sum dishes:</p>
<div id="e43c1e8f" class="cell" data-execution_count="70">
<div class="cell-output cell-output-display">

   <div style="text-align: center;">
      <div style="display: inline-block; width: 80%;">
         
<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th">CustomerID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C002</td>
</tr>
</tbody>
</table>

      </div>
   </div>
</div>
</div>
<p>This query performs a <strong>division</strong> operation to find customers who have ordered <strong>all</strong> the dim sum dishes listed in the <code>DimSum</code> table. The result shows only those customers (in this case, <code>CustomerID: C002</code>) who have ordered all available dishes.</p>
<ul>
<li>The <code>CustomerID</code> of the customer(s) who ordered every dim sum dish (from the <code>DimSum</code> table) will be displayed.</li>
</ul>
</div></div>
<!-- -->
</section>
<section id="practical-use-case-for-division" class="slide level2">
<h2>Practical Use Case for Division</h2>
<p>Division is especially useful in scenarios where a tuple needs to be related to all tuples in another relation, such as students attending all classes or employees assigned to all projects.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Example: “Find suppliers who supply all products in a given category.”</li>
<li>Applicable in situations where completeness across multiple related attributes is required.</li>
<li>Helps with queries involving all relationships between a set of tuples.</li>
<li>Simplifies queries that would otherwise require multiple joins or nested operations.</li>
<li>Especially common in constraint-related queries, such as project assignments.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Division is ideal for scenarios where a record must meet all criteria in a related set.</em></p>
</section>
<section id="common-mistakes-with-division" class="slide level2">
<h2>Common Mistakes with Division</h2>
<p>Although powerful, division can be misused or misunderstood, particularly in situations where its requirements aren’t fully met. This slide highlights common pitfalls to avoid.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Confusing division with joins, especially in multi-relation queries.</li>
<li>Forgetting that all tuples in the divisor must match for a result to be returned.</li>
<li>Misinterpreting the need for completeness across tuples in both relations.</li>
<li>Using division in cases where a simple join would suffice.</li>
<li>Failing to project the correct attributes before performing the operation.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Avoid these common errors to ensure the correct application of division in your queries.</em></p>
</section>
<section id="renaming-and-division-in-query-design" class="slide level2">
<h2>Renaming and Division in Query Design</h2>
<p>Combining renaming and division can lead to highly readable, efficient queries. This slide demonstrates how these operations complement each other in practice.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Renaming helps clarify relations and attributes before applying division.</li>
<li>Avoids ambiguity when the same attributes are present in both relations.</li>
<li>Ensures that division works on correctly named attributes.</li>
<li>Improves readability of queries, especially in complex database structures.</li>
<li>Example: <code>ρ(StudentCourses/AllCourses)</code> can clarify query intent and results.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Renaming can simplify and clarify the application of division in query design.</em></p>
</section>
<section id="limitations-of-division-in-relational-algebra" class="slide level2">
<h2>Limitations of Division in Relational Algebra</h2>
<p>Division, while useful, has limitations and is not appropriate for all query types. Understanding these constraints will help avoid unnecessary complexity in queries.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Division requires exact matching across relations, which may not be flexible enough for some queries.</li>
<li>Not suitable for situations where partial matches are acceptable.</li>
<li>Can be less intuitive than other relational operations like join or projection.</li>
<li>Often difficult to optimize in large databases due to its complexity.</li>
<li>Sometimes requires preprocessing or additional operations to work effectively.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Division is powerful but limited by its strict requirements for matching across relations.</em></p>
</section>
<section id="alternatives-to-division" class="slide level2">
<h2>Alternatives to Division</h2>
<p>In cases where division is not the best fit, other relational operations may be more appropriate. This slide explores alternatives such as joins and nested queries.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Join operations, including natural and theta joins, often provide more flexible alternatives to division.</li>
<li>Nested queries can sometimes replace division, offering more control over specific conditions.</li>
<li>Set operations like intersection and difference may achieve similar results.</li>
<li>Depending on the database design, a series of joins and selections may be more efficient.</li>
<li>SQL often handles division-like queries using alternative constructs like <code>HAVING</code> or correlated subqueries.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Consider alternatives to division when its strict requirements don’t fit the query’s needs.</em></p>
</section>
<section id="summary-of-renaming-and-division" class="slide level2">
<h2>Summary of Renaming and Division</h2>
<p>Renaming and division are important operations in relational algebra, each with its own use cases and limitations. Properly applied, these tools enhance both query design and execution.</p>
<div class="columns">
<div class="column" style="width:98%;">
<ul>
<li>Renaming clarifies queries by giving distinct names to relations and attributes.</li>
<li>Division helps identify tuples related to all members of another relation.</li>
<li>Division is strict and requires complete matching, while renaming aids in query readability.</li>
<li>Both operations are essential for complex query design and practical database management.</li>
<li>Combining these tools can lead to clearer and more efficient relational queries.</li>
</ul>
</div><div class="column" style="width:1%;">

</div><div class="column" style="width:1%;">

</div></div>
<!-- -->
<p><em>Understanding renaming and division allows for more advanced and efficient database queries.</em></p>
<!-- lecture-block-end -->
</section>
<section id="housekeeping-1" class="slide level2">
<h2>Housekeeping</h2>
<div class="columns">
<div class="column" style="width:9%;">

</div><div class="column" style="width:45%;">
<h3 id="discussion-items-1">Discussion items</h3>
<ul>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/quizzes/211171">Practice Quiz 2 </a> - due Feb.&nbsp;4, TUE</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1072335">Homework 2 - ER Modeling </a> - due Feb.&nbsp;4, TUE</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1075914">Discussion 2 - Relational Algebra</a> - due Feb.&nbsp;9, SUN</p></li>
<li><p><a href="https://virginiacommonwealth.instructure.com/courses/113813/assignments/1075768">Del.4 - Video Pitch</a> - due Feb.&nbsp;9, SUN</p></li>
</ul>
</div><div class="column" style="width:40%;">
<h3 id="lecture-topics-1">Lecture topics</h3>
<ul>
<li><p><a href="#/deliverable-4-notes">Deliverable 4 Notes</a></p></li>
<li><p><a href="#/set-operations">Set Operations</a></p></li>
<li><p><a href="#/join-operations">Join Operations</a></p></li>
<li><p><a href="#/rename-and-division">Renaming and Division</a></p></li>
</ul>
</div></div>
<div style="margin-top:25px">
<p>&nbsp;</p>
</div>

    <style></style>
    <div class="upcoming-calendar">
<table class="caption-top" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th style="text-align: center;" data-quarto-table-cell-role="th">Module</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Week</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Date</th>
<th style="text-align: center;" data-quarto-table-cell-role="th">Day</th>
<th data-quarto-table-cell-role="th">Notes and Lectures</th>
<th data-quarto-table-cell-role="th">Activities and due dates</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/4</td>
<td style="text-align: center;">Tue</td>
<td>L7:Relational Algebra 1</td>
<td>PQ2:Relational Algebra; HW2:Entity Relation Models</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/6</td>
<td style="text-align: center;">Thu</td>
<td>L8:Relational Algebra 2</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2/9</td>
<td style="text-align: center;">Sun</td>
<td></td>
<td>Prj4:Video Pitch; Dis2:Relational Alg.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/10</td>
<td style="text-align: center;">Mon</td>
<td>Last day for progress reports</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/11</td>
<td style="text-align: center;">Tue</td>
<td>L9:Analysis and Normal Forms 1</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/12</td>
<td style="text-align: center;">Wed</td>
<td>Career Fair (10am-3pm)</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/13</td>
<td style="text-align: center;">Thu</td>
<td>NO CLASS - Interview Day (10am-3pm)</td>
<td>Q2:Relational Algebra</td>
</tr>
<tr class="even">
<td style="text-align: center;">Relational Alg.</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2/16</td>
<td style="text-align: center;">Sun</td>
<td></td>
<td>HW3:Modeling Your World</td>
</tr>
</tbody>
</table>
</div>

<div class="reveal-header">
<div class="header-logo">
<img data-src="assets/CS-icon-with-dept-name-white-2.png">
</div>
<div class="sc-title">
<p> </p>
</div>
<div class="header-text">
<p>CMSC 408 - Databases</p>
</div>
<div class="sb-title">
<p> </p>
</div>
</div>
</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<p><img src="assets/CS-icon-01.png" class="slide-logo"></p>
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="lecture-08_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="lecture-08_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="lecture-08_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="lecture-08_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"8\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":false},
'chalkboard': {"buttons":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 900,

        height: 500,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,

        maxScale: 2,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const onCopySuccess = function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      }
      const getTextToCopy = function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
        text: getTextToCopy
      });
      clipboard.on('success', onCopySuccess);
      if (window.document.getElementById('quarto-embedded-source-code-modal')) {
        const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
          text: getTextToCopy,
          container: window.document.getElementById('quarto-embedded-source-code-modal')
        });
        clipboardModal.on('success', onCopySuccess);
      }
        var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
        var mailtoRegex = new RegExp(/^mailto:/);
          var filterRegex = new RegExp('/' + window.location.host + '/');
        var isInternal = (href) => {
            return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
        }
        // Inspect non-navigation links and adorn them if external
     	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
        for (var i=0; i<links.length; i++) {
          const link = links[i];
          if (!isInternal(link.href)) {
            // undo the damage that might have been done by quarto-nav.js in the case of
            // links that we want to consider external
            if (link.dataset.originalHref !== undefined) {
              link.href = link.dataset.originalHref;
            }
          }
        }
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note) {
            return note.innerHTML;
          } else {
            return "";
          }
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>
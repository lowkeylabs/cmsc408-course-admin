---
date: 10/2/2023
lecture-id: 9
title: Analysis and Normal Forms 2
---

```{python}
#| echo: false
lecture_id = 9
n_rows = 8
```

## Housekeeping

- [Review week 7 materials](https://virginiacommonwealth.instructure.com/courses/85746/modules)
- [Review Homework 5](https://virginiacommonwealth.instructure.com/courses/85746/assignments/732261?module_item_id=2903763)
- Quiz 3 next Wednesday, October 11 covering normalization

<p>&nbsp;</p>

```{python}
#| echo: false
from src.utils import upcoming_calendar
# Set the lecture ID and number of rows to show at the top of this file!
upcoming_calendar( lecture_id, n_rows )
```

# Terms and definitions

## Terms and definitions - Schema - Example 1

A *schema* is a collection of relations (tables). A *schema* is said
to be in *Boyce-Codd Normal Form* when ALL the relations in the *schema*
are in BCNF.  BCNF minimizes redundancy and duplicate information.

:::: {.columns}
::: {.column width=45%}

::: {style="font-size:10pt"}

| RID | Course Code | First   | Last      | Language   |
|---|-------------|---------|-----------|------------|
| 1 | CMSC508     | John    | Leonard   | SQL        |
| 1 | CMSC508     | John    | Leonard   | Python     |
| 1 | CMSC508     | John    | Leonard   | Perl       |
| 2 | CMSC508     | Alberto | Cano      | SQL        |
| 2 | CMSC508     | Alberto | Cano      | Python     |
| 2 | CMSC508     | Alberto | Cano      | C++        |
| 3 | CMSC475     | John    | Leonard   | Javascript |
| 3 | CMSC475     | John    | Leonard   | Python     |
| 4 | CMSC441     | Bob     | Dahlberg  | COBOL      |
| 4 | CMSC441     | Bob     | Dahlberg  | FORTRAN    |
| 5 | CMSC320     | Sarah   | Adams     | C++        |
| 5 | CMSC320     | Sarah   | Adams     | Java       |
| 5 | CMSC320     | Sarah   | Adams     | Python     |
| 6 | CMSC210     | Michael | Turner    | Java       |
| 6 | CMSC210     | Michael | Turner    | C#         |
| 7 | CMSC515     | Emily   | Parker    | Python     |
| 7 | CMSC515     | Emily   | Parker    | MATLAB     |
| 8 | CMSC430     | Jessica | Clark     | HTML       |
| 8 | CMSC430     | Jessica | Clark     | CSS        |
| 8 | CMSC430     | Jessica | Clark     | JavaScript |
| 9 | CMSC610     | Alberto | Cano      | Python     |
| 9 | CMSC610     | Alberto | Cano      | R          |
:::

:::

::: {.column width=28%}

::: {style="font-size:10pt"}

| Course Code | Course Name       |
|-------------|-------------------|
| CMSC210     | Software Design   |
| CMSC320     | Data Structures   |
| CMSC430     | Web Development   |
| CMSC441     | Capstone          |
| CMSC475     | UI/UX design      |
| CMSC508     | Databases         |
| CMSC515     | Computer Vision   |
| CMSC610     | Machine Learning  |

<p>&nbsp;</p>

|  First   |    Last  |
|----------|----------|
|  Alberto | Cano     |
|  Bob     | Dahlberg |
|  Sarah   | Adams    |
|  John    | Leonard  |
|  Michael | Turner   |
|  Emily   | Parker   |
|  Jessica | Clark    |

:::

:::

::: {.column width=10%}

::: {style="font-size:10pt"}

| Language   |
|------------|
| SQL        |
| Python     |
| Perl       |
| C++        |
| Javascript |
| COBOL      |
| FORTRAN    |
| Java       |
| C#         |
| MATLAB     |
| HTML       |
| CSS        |
| R          |


:::

:::

::: {.column width=9%}

::: {style="font-size:10pt"}

| RID |
|---|
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

:::
:::
::::

## Terms and definitions - Schema - Example 2

:::: {.columns}
::: {.column width=60%}

::: {style="font-size:10pt"}

| RID  | Course                   | Instructor     | Languages             |
|------|--------------------------|----------------|-----------------------|
|  1   | CMSC508 Databases        | John Leonard   | SQL, Python, Perl     |
|  2   | CMSC508 Databases        | Alberto Cano   | SQL, Python, C++      |
|  3   | CMSC475 UI/UX design     | John Leonar    | Javascript, Python    |
|  4   | CMSC441 Capstone         | Bob Dahlberg   | COBOL, FORTRAN        |
|  5   | CMSC320 Data Structures  | Sarah Adams    | C++, Java, Python     |
|  6   | CMSC210 Software Design  | Michael Turner | Java, C#              |
|  7   | CMSC515 Computer Vision  | Emily Parker   | Python, MATLAB        |
|  8   | CMSC430 Web Development  | Jessica Clark  | HTML, CSS, JavaScript |
|  9   | CMSC610 Machine Learning | Albert Cano    | Python, R             |

:::

:::
::: {.column width="39%"}
::: {style="font-size:11pt"}
The *schema* on the left contains multi-valued dependencies,
making it difficult to retrieve information.

However, this schema does make it easy to see groups of related data stored within each row. We use *functional dependencies* to document these relationships.

*Functional dependencies* are an INPUT - that is, the database designer is responsible for describing the relationships between columns in their schema.

We define *normal forms* to describe the strictness of the *functional dependencies.*

Given any schema $S$ consisting of relations $R$ and set of functional dependencies $F$ for each $R$, a schema is said to be in BCNF when all the relations in $S$ are in BCNF.

The schema on the left, which consists of only one relation, has multivalued dependencies and transitive dependencies and is not in BCNF.

Our goal is to design and implement schemas that are BCNF.
:::

:::
::::

## Functional Dependencies - Defined

::: {style="font-size:14pt"}
Given a relation $R$, a set of attributes $X$ is said to *functionally determine* another set of attributes $Y$, (written $X \rightarrow Y$):

* If and only if, each value of $X$ is associated with only one value of $Y$, where $X$ is the antecedent and $Y$ is the consequent of the functional dependency.

A functional dependency $X \rightarrow Y$ holds over relation $R$ if, for every allowable instance $r$ of $R$:

* For $𝑡_1 \in 𝑟$ and $𝑡_2 \in 𝑟$, $\Pi_{𝑋}(𝑡_1) = \Pi_{𝑋}(𝑡_2)$  implies $\Pi_{𝑌}(𝑡_1) = \Pi_{𝑌}(𝑡_2)$

If the $X$ values agree then the $Y$ values must also agree.

### Summary 

* A FD is a statement about relationships between attributes (columns).
* A FD can only and must be identified based on semantics of the application not on current values.
* Given some allowable instances of R, we can check if they violate some FDs, but we cannot tell if always holds over R!

:::

## Functional Dependencies - Notations

:::: {.columns}
::: {.column width=60%}

::: {style="font-size:10pt"}

| RID  | Course                   | Instructor     | Languages             |
|------|--------------------------|----------------|-----------------------|
|  1   | CMSC508 Databases        | John Leonard   | SQL, Python, Perl     |
|  2   | CMSC508 Databases        | Alberto Cano   | SQL, Python, C++      |
|  3   | CMSC475 UI/UX design     | John Leonar    | Javascript, Python    |
|  4   | CMSC441 Capstone         | Bob Dahlberg   | COBOL, FORTRAN        |
|  5   | CMSC320 Data Structures  | Sarah Adams    | C++, Java, Python     |
|  6   | CMSC210 Software Design  | Michael Turner | Java, C#              |
|  7   | CMSC515 Computer Vision  | Emily Parker   | Python, MATLAB        |
|  8   | CMSC430 Web Development  | Jessica Clark  | HTML, CSS, JavaScript |
|  9   | CMSC610 Machine Learning | Albert Cano    | Python, R             |

:::

:::
::: {.column width="39%"}
The *schema* $S$ on the left consists of one *relation* $R$.

Notation 1:

* Response( RID, Course, Instructor, Languages )
* Functional Dependencies:
    - RID -> Course, Instructor, Languages
    - Instructor -> Languages

Notation 2:

* R( A,B,C,D )
* F( A->B,C,D; C->D )

Big questions:

* Is $S$ in BCNF?
* If not, how do we get there?

:::
::::


## Normal Forms - Overview

:::: {.columns}
::: {.column width=50%}

Database normalization is the process of reorganizing the relations $R$ in a schema $S$ to minimize data redundancy.

Normalization involves subdividing a relation $R$ into less redundant and smaller relations (fewer columns) without losing information by leveraging the functional dependencies (relationships) of $R$.

The objective is to isolate related data to minimize duplicates and so modifications of an attribute can be made in just one table and then propagated through the rest of the database using the defined foreign keys and joins.

Escalating through the different normal forms removes more and more redundancy.

:::
::: {.column width=50%}

![](assets/normal-forms-picture.png)

:::
::::

## Normal Forms - Defined

:::: {.columns}
::: {.column}
### The usual suspects

First Normal Form - 1NF
: A relation is in 1NF if and only if the domain of each attribute contains only atomic (indivisible) values and the value of each attribute contains only a single value from that domain.

Second Normal Form - 2NF
: A relation is in 2NF if and only if it is in 1NF and all non-prime attributes (attributes not part of any candidate key) are fully functionally dependent on the entire candidate key.

Third Normal Form - 3NF
: A relation is in 3NF if and only if it is in 2NF, and it has no transitive dependencies.

Boyce-Codd Normal Form - BCNF
: A relation is in BCNF if and only if it is in 1NF, and for every non-trivial functional dependency A -> B, A is a superkey.

:::
::: {.column}
### Crazy talk

Fourth Normal Form - 4NF
: A relation is in 4NF if and only if it is in BCNF, and it has no multi-valued dependencies.

Fifth Normal Form - 5NF
: A relation is in 5NF if and only if it is in 4NF, and it avoids join dependencies.

Sixth Normal Form - 6NF
: A relation is in 6NF if and only if it is in 5NF, and it further eliminates all join dependencies and assures that every join dependency can be enforced by the superkeys of the relation.

Seventh Normal Form - 7NF
: A relation is in 7NF if and only if it is in 6NF, and it eliminates all combinatorial join dependencies, ensuring that every possible join dependency is addressed.

:::
::::

# Recognizing BCNF

## Boyce-Codd Normal Form (BCNF) - Example 1

:::: {.columns}
::: {.column width=50%}

A relation $R$ with functional dependencies $F$ is in BCNF if for all
$X \rightarrow Y$ in $F_{min}^+$:

* $Y \subseteq X$ (the trival FD), **OR**
* $X$ is a superkey for $R$

A relation is in BCNF if and only if it is in 1NF, and for every non-trivial functional dependency $A \rightarrow B$, $A$ is a superkey.

:::
::: {.column width=50%}
### Trivial FD{style="text-align:center"}
::: {style="font-size:10pt"}

| Language   |
|------------|
| SQL        |
| Python     |
| Perl       |
| C++        |
| Javascript |


:::
:::
::::
### Trival:  $X \rightarrow X$

```{dot}
//| echo: false
//| fig-width: 800px
//| fig-height: 100px
digraph G {
    node [shape=ellipse]; // Set the shape of nodes to ellipses
    bgcolor="#00000000";
    {rank=same;
    // Define the four nodes
    A [label="Language"];
    }
    // Arrange the nodes in a horizontal row
}
```

## Boyce-Codd Normal Form (BCNF) - Example 2

:::: {.columns}
::: {.column width=50%}

A relation $R$ with functional dependencies $F$ is in BCNF if for all
$X \rightarrow Y$ in $F_{min}^+$:

* $Y \subseteq X$ (the trival FD), **OR**
* $X$ is a superkey for $R$

A relation is in BCNF if and only if it is in 1NF, and for every non-trivial functional dependency $A \rightarrow B$, $A$ is a superkey.

:::
::: {.column width=50%}
### Non-composite key {style="text-align:center"}
::: {style="font-size:10pt"}

| Course Code | Course Name       |
|-------------|-------------------|
| CMSC210     | Software Design   |
| CMSC320     | Data Structures   |
| CMSC430     | Web Development   |
| CMSC441     | Capstone          |
| CMSC475     | UI/UX design      |
| CMSC508     | Databases         |
| CMSC515     | Computer Vision   |
| CMSC610     | Machine Learning  |

:::
:::
::::
### Non-composite key:  $X \rightarrow Y$

```{dot}
//| echo: false
//| fig-width: 800px
//| fig-height: 100px
digraph G {
    node [shape=ellipse]; // Set the shape of nodes to ellipses
    bgcolor="#00000000";
    {rank=same;
    // Define the four nodes
    A [label="Course code"];
    B [label="Course name"];
    }
    // Arrange the nodes in a horizontal row
    A -> B;
}
```

## Boyce-Codd Normal Form (BCNF) - Example 3

:::: {.columns}
::: {.column width=50%}

A relation $R$ with functional dependencies $F$ is in BCNF if for all
$X \rightarrow Y$ in $F_{min}^+$:

* $Y \subseteq X$ (the trival FD), **OR**
* $X$ is a superkey for $R$

A relation is in BCNF if and only if it is in 1NF, and for every non-trivial functional dependency $A \rightarrow B$, $A$ is a superkey.

:::
::: {.column width=50%}
### Composite key {style="text-align:center"}
::: {style="font-size:10pt"}

|  First   |    Last  |   Major   |
|----------|----------|-----------|
|  Alberto | Cano     |  Comp Sci  |
|  Bob     | Dahlberg |  History  |
|  Sarah   | Adams    |  Biology  |
|  John    | Leonard  |  Civil Engr|
|  Michael | Turner   |  Comp Sci |
|  Emily   | Parker   |  English  |
|  Jessica | Clark    |  Mathematics |

:::
:::
::::

### Composite key:  ${A,B} \rightarrow C$

```{dot}
//| echo: false
//| fig-width: 800px
//| fig-height: 100px
digraph G {
    node [shape=ellipse]; // Set the shape of nodes to ellipses
    bgcolor="#00000000";
    {rank=same;
    // Define the four nodes
    A [label="First, Last"];
    B [label="Major"];
    }
    // Arrange the nodes in a horizontal row
    A -> B;
}
```

## Boyce-Codd Normal Form (BCNF) - Terms

:::: {.columns}
::: {.column width=50%}

A relation $R$ with functional dependencies $F$ is in BCNF if for all
$X \rightarrow Y$ in $F_{min}^+$:

* $Y \subseteq X$ (the trival FD), **OR**
* $X$ is a superkey for $R$

A relation is in BCNF if and only if it is in 1NF, and for every non-trivial functional dependency $A \rightarrow B$, $A$ is a superkey.

:::
::: {.column width=50%}
### Terms
::: {style="font-size:11.5pt; margin-top:-12px"}
* Schemas and relations
* Functional dependencies
* Keys: Superkey, key, composite key
* Prime and non-prime attributes
* Armstrong's Axioms
* Attribute closures
* Minimum candidate keys
* $F_{min}^+$ - minimal cover set
:::
:::
::::

<p>&nbsp;</p>
### Non-composite key: $A \rightarrow {B,C,D}$
```{dot}
//| echo: false
//| fig-width: 800px
//| fig-height: 100px
digraph G {
    node [shape=ellipse]; // Set the shape of nodes to ellipses
    bgcolor="#00000000";
    {rank=same;
     // Define the four nodes
        A [label="A: Prime / Key"];
        B [label="D: Non prime attr"];
        C [label="C: Non prime attr"];
        D [label="B: Non prime attr"];
    }
    // Arrange the nodes in a horizontal row
    A -> D;
    A -> C;
    A -> B;
}
```

::: {style="text-align:center"}
*The superkey, the whole key, and nothing but the key, so help me Codd!*
:::

## Boyce-Codd Normal Form (BCNF) - An algorithm

:::: {.columns}
::: {.column width=45%}
### Algorithm
Repeat for each relation $R$ in schema $S$:

- Calculate attribute closures ${\{X\}}^+$
- Determine minimum candidate keys ${C\!K}_{min}$
- Determine prime and non-prime attributes
- Determine minimal cover set $F_{min}^+$
- Determine highest normal form of relation $R$
- Decompose input relation $R$ into BCNF

Until all relations $R$ in schema $S$ are BCNF.
:::
::: {.column width=50%}
### Skills for CMSC 508

- By inspection determine if a relation $R$ is BCNF,
- Translate schema $S$ into relational algebraic form,
- Document functional dependencies for each $R$ in $S$,
- Run [calculator by Raymond Cho](http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html),
- Describe reports and algorithms used by calculator,
- Interpret reports to find necessary outputs,
- Identify decomposed BCNF relations from report.

:::
::::

## Boyce-Codd Normal Form (BCNF) - A Worked Example

:::: {.columns}
::: {.column width=60%}

::: {style="font-size:10pt"}

| RID  | Course                   | Instructor     | Languages             |
|------|--------------------------|----------------|-----------------------|
|  1   | CMSC508 Databases        | John Leonard   | SQL, Python, Perl     |
|  2   | CMSC508 Databases        | Alberto Cano   | SQL, Python, C++      |
|  3   | CMSC475 UI/UX design     | John Leonard   | Javascript, Python    |
|  4   | CMSC441 Capstone         | Bob Dahlberg   | COBOL, FORTRAN        |
|  5   | CMSC320 Data Structures  | Sarah Adams    | C++, Java, Python     |
|  6   | CMSC210 Software Design  | Michael Turner | Java, C#              |
|  7   | CMSC515 Computer Vision  | Emily Parker   | Python, MATLAB        |
|  8   | CMSC430 Web Development  | Jessica Clark  | HTML, CSS, JavaScript |
|  9   | CMSC610 Machine Learning | Alberto Cano   | Python, R             |

:::

:::
::: {.column width="39%"}
The *schema* $S$ on the left consists of one *relation* $R$.

In relational model notation:

* $R( A,B,C,D )$
* $F( A \rightarrow B,C,D; B,C \rightarrow D )$

Now for some quick math:

- [Inside the calculator by Raymond Cho](http://raymondcho.net/RelationalDatabaseTools/RelationalDatabaseTools.html),

And the resulting schema in BCNF:

* $R_0(A,B,C)$, and
* $R_1(B,C,D)$


:::
::::

## Housekeeping

- [Review week 7 materials](https://virginiacommonwealth.instructure.com/courses/85746/modules)
- [Review Homework 5](https://virginiacommonwealth.instructure.com/courses/85746/assignments/732261?module_item_id=2903763)
- Quiz 3 next Wednesday, October 11 covering normalization
- On Wednesday do more problems and explore Homework 5.

<p>&nbsp;</p>

```{python}
#| echo: false
from src.utils import upcoming_calendar
# Set the lecture ID and number of rows to show at the top of this file!
upcoming_calendar( lecture_id, n_rows )
```